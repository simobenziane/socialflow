{
  "name": "00_API_Endpoints_v17",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "=GET",
        "path": "api",
        "responseMode": "responseNode",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Methods",
                "value": "GET, POST, PUT, DELETE, OPTIONS"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type, Authorization"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        0,
        500
      ],
      "id": "api-webhook-get",
      "name": "GET Webhook",
      "webhookId": "api-webhook"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api",
        "responseMode": "responseNode",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Methods",
                "value": "GET, POST, PUT, DELETE, OPTIONS"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type, Authorization"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        0,
        700
      ],
      "id": "api-webhook-post",
      "name": "POST Webhook",
      "webhookId": "api-webhook-post"
    },
    {
      "parameters": {
        "httpMethod": "PUT",
        "path": "api",
        "responseMode": "responseNode",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Methods",
                "value": "GET, POST, PUT, DELETE, OPTIONS"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type, Authorization"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        0,
        900
      ],
      "id": "api-webhook-put",
      "name": "PUT Webhook",
      "webhookId": "api-webhook-put"
    },
    {
      "parameters": {
        "httpMethod": "DELETE",
        "path": "api",
        "responseMode": "responseNode",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Methods",
                "value": "GET, POST, PUT, DELETE, OPTIONS"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type, Authorization"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        0,
        1100
      ],
      "id": "api-webhook-delete",
      "name": "DELETE Webhook",
      "webhookId": "api-webhook-delete"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const items = $input.all();\nconst merged = [];\nfor (const item of items) {\n merged.push(item);\n}\nreturn merged;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        240,
        700
      ],
      "id": "api-merge",
      "name": "Merge Requests"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// W-API v17: Route Parser\nconst input = $input.first().json;\nconst method = input.method || 'GET';\nconst query = input.query || {};\nconst body = input.body || {};\n\nconst route = query.route || body.route || '/health';\n\nconst CONFIG_BASE = '/data/clients/_config';\nconst DB_PATH = `${CONFIG_BASE}/socialflow.db`;\n\nconsole.log(`[API] ${method} ${route}`);\n\nreturn [{\n json: {\n route: route,\n method: method,\n query: query,\n body: body,\n db_path: DB_PATH,\n config_base: CONFIG_BASE\n }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        700
      ],
      "id": "api-router",
      "name": "Route Parser"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n// â•‘ W-API v17: ROUTE HANDLER - Enhanced with Agent Instructions â•‘\n// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst Database = require('better-sqlite3');\nconst fs = require('fs');\nconst crypto = require('crypto');\n\nconst input = $input.first().json;\nconst { route, method, query, body, db_path, config_base } = input;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// HELPER FUNCTIONS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nfunction success(data, message = 'OK') {\n return { success: true, message, data, timestamp: new Date().toISOString() };\n}\n\nfunction error(message, code = 400) {\n return { success: false, error: message, code, timestamp: new Date().toISOString() };\n}\n\nfunction parseRoute(route) {\n // Handle query params in route\n const routePath = route.split('?')[0];\n const parts = routePath.split('/').filter(p => p);\n return { parts, base: parts[0] || 'health' };\n}\n\n// Status constants for type safety\nconst STATUS = {\n PENDING: 'PENDING',\n NEEDS_AI: 'NEEDS_AI',\n NEEDS_REVIEW: 'NEEDS_REVIEW',\n APPROVED: 'APPROVED',\n SCHEDULED: 'SCHEDULED',\n FAILED: 'FAILED',\n DELETED: 'DELETED',\n REJECTED: 'REJECTED',\n BLOCKED: 'BLOCKED'\n};\n\n// Valid content item statuses (whitelist for SQL injection prevention)\nconst VALID_STATUSES = Object.values(STATUS);\n\n// Parse JSON fields from client record\nfunction parseClientJSON(client) {\n if (!client) return client;\n return {\n ...client,\n hashtags: JSON.parse(client.hashtags || '[]'),\n platform_defaults: JSON.parse(client.platform_defaults || '{}'),\n policy: JSON.parse(client.policy || '{}')\n };\n}\n\n// Parse JSON fields from batch record\nfunction parseBatchJSON(batch) {\n if (!batch) return batch;\n return {\n ...batch,\n hashtags: JSON.parse(batch.hashtags || '[]'),\n schedule_config: JSON.parse(batch.schedule_config || '{}')\n };\n}\n\n// Validate schedule item format\n\n// Lookup all accounts from a Late.com profile\nfunction lookupProfileAccounts(profileId, configBase) {\n const cachePath = configBase + '/late_accounts.json';\n if (!fs.existsSync(cachePath)) return [];\n try {\n const cacheData = JSON.parse(fs.readFileSync(cachePath, 'utf8'));\n const accounts = cacheData.accounts || [];\n return (accounts || []).filter(a => getAccountProfileId(a) === profileId);\n } catch (e) {\n console.log('[API] Failed to lookup profile accounts:', e.message);\n return [];\n }\n}\n\n// Lookup profile info from cache\nfunction lookupProfile(profileId, configBase) {\n const cachePath = configBase + '/late_accounts.json';\n if (!fs.existsSync(cachePath)) return null;\n try {\n const cacheData = JSON.parse(fs.readFileSync(cachePath, 'utf8'));\n const profiles = cacheData.profiles || [];\n return profiles.find(p => p.id === profileId) || null;\n } catch (e) {\n console.log('[API] Failed to lookup profile:', e.message);\n return null;\n }\n}\n\n// Lookup username from late_accounts.json cache\nfunction lookupAccountUsername(accountId, configBase) {\n const cachePath = configBase + '/late_accounts.json';\n if (!fs.existsSync(cachePath)) return '';\n try {\n const cacheData = JSON.parse(fs.readFileSync(cachePath, 'utf8'));\n const accounts = cacheData.accounts || [];\n const acc = accounts.find(a => a.id === accountId);\n return acc?.username || '';\n  } catch (e) {\n    console.log('[API] Failed to lookup account username:', e.message);\n    return '';\n  }\n}\n\nfunction validateScheduleItem(item) {\n if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(item.scheduled_date)) {\n throw new Error(`Invalid date format for item ${item.id}: expected YYYY-MM-DD`);\n }\n if (!/^\\d{2}:\\d{2}(:\\d{2})?$/.test(item.scheduled_time)) {\n throw new Error(`Invalid time format for item ${item.id}: expected HH:MM or HH:MM:SS`);\n }\n if (item.slot && !['feed', 'story'].includes(item.slot)) {\n throw new Error(`Invalid slot for item ${item.id}: must be feed or story`);\n }\n}\n// Helper to extract profile ID from account (handles object or string format)\nfunction getAccountProfileId(account) {\n  if (!account || !account.late_profile_id) return null;\n  return typeof account.late_profile_id === 'object'\n    ? account.late_profile_id._id\n    : account.late_profile_id;\n}\n\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// CHECK DATABASE (skip for some routes)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst skipDbRoutes = ['health', 'settings', 'late', 'jobs'];\nconst { parts, base } = parseRoute(route);\n\nif (!fs.existsSync(db_path) && !skipDbRoutes.includes(base)) {\n return [{ json: error('Database not found. Run init_database.js first.', 500) }];\n}\n\nlet result = {};\n\ntry {\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // HEALTH CHECK\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n if (route === '/health' || base === 'health') {\n result = success({\n status: 'healthy',\n version: 'v17',\n database: fs.existsSync(db_path) ? 'connected' : 'not_found',\n storage: 'SQLite'\n }, 'API is healthy');\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // SETTINGS - Get/Update application settings\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (base === 'settings') {\n const settingsPath = `${config_base}/settings.json`;\n \n if (!fs.existsSync(settingsPath)) {\n result = error('Settings file not found', 500);\n }\n // POST /settings/test-cloudflare - Test Cloudflare tunnel connectivity\n else if (parts[1] === 'test-cloudflare' && method === 'POST') {\n try {\n const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n const cfUrl = settings.cloudflare_tunnel_url;\n \n if (!cfUrl || !cfUrl.startsWith('https://')) {\n result = { success: false, message: 'No valid Cloudflare URL configured', url: cfUrl };\n } else {\n // Return a special flag to trigger HTTP test in a separate workflow path\n // The actual test will be done via n8n's HTTP Request node\n result = { \n _test_cloudflare: true, \n test_url: `${cfUrl}/_config/settings.json?_t=${Date.now()}`,\n cloudflare_url: cfUrl \n };\n }\n } catch (err) {\n result = error(`Test failed: ${err.message}`, 500);\n }\n }\n else if (method === 'PUT' || method === 'POST') {\n // Update settings\n const current = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n const updates = body || {};\n \n // Shallow merge with nested object support\n const merged = { ...current };\n \n // Handle top-level fields\n if (updates.cloudflare_tunnel_url !== undefined) {\n merged.cloudflare_tunnel_url = updates.cloudflare_tunnel_url;\n }\n \n // Handle nested objects\n if (updates.paths) {\n merged.paths = { ...current.paths, ...updates.paths };\n }\n if (updates.ollama) {\n merged.ollama = { ...current.ollama, ...updates.ollama };\n }\n if (updates.ai_provider !== undefined) {\n merged.ai_provider = updates.ai_provider;\n }\n if (updates.gemini) {\n merged.gemini = { ...current.gemini, ...updates.gemini };\n }\n if (updates.defaults) {\n merged.defaults = { ...current.defaults, ...updates.defaults };\n }\n if (updates.late_api) {\n merged.late_api = { ...current.late_api, ...updates.late_api };\n }\n if (updates.database) {\n merged.database = { ...current.database, ...updates.database };\n }\n \n // Write back (atomic: write to .tmp then rename)\n const settingsTmp = `${settingsPath}.tmp`;\n fs.writeFileSync(settingsTmp, JSON.stringify(merged, null, 2));\n fs.renameSync(settingsTmp, settingsPath);\n \n // Return without deprecated fields\n const response = { ...merged };\n delete response.google_sheets;\n \n result = success(response, 'Settings updated');\n }\n else {\n // GET settings\n const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n \n // Remove deprecated fields for UI\n delete settings.google_sheets;\n \n result = success(settings, 'Settings loaded');\n }\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // LATE - Late.com account cache and sync\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (base === 'late') {\n if (parts[1] === 'accounts') {\n const cachePath = `${config_base}/late_accounts.json`;\n \n if (!fs.existsSync(cachePath)) {\n result = success({ accounts: [], profiles: [], synced_at: null }, 'No cached accounts - run sync first');\n } else {\n let data;\n try {\n data = JSON.parse(fs.readFileSync(cachePath, 'utf8'));\n } catch (parseError) {\n console.log('[API] ⚠ Cache file corrupted, returning empty data:', parseError.message);\n result = success({ accounts: [], profiles: [], synced_at: null }, 'Cache file corrupted - please re-sync');\n }\n // Only set result if parse succeeded (check if result is empty object)\n  if (Object.keys(result).length === 0) {\n \n result = success(data, 'Cached accounts loaded');\n }\n }\n }\n else if (parts[1] === 'sync' && method === 'POST') {\n // Return instruction to call W0 webhook\n result = success({ action: 'trigger_w0_sync', webhook: '/w0-sync' }, 'Trigger W0 sync via webhook /w0-sync');\n }\n else {\n result = error(`Unknown late route: ${route}`, 404);\n }\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // JOBS - Job tracking status for UI retry support\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (base === 'jobs') {\n const jobPath = `${config_base}/active_job.json`;\n \n if (!fs.existsSync(jobPath)) {\n result = success({\n current: { client: null, batch: null },\n executions: { W0: null, W1: null, W2: null, W3: null }\n }, 'No job tracking data - run a workflow first');\n } else {\n try {\n const jobs = JSON.parse(fs.readFileSync(jobPath, 'utf8'));\n \n // Ensure structure exists\n if (!jobs.current) jobs.current = { client: null, batch: null };\n if (!jobs.executions) jobs.executions = { W0: null, W1: null, W2: null, W3: null };\n \n result = success(jobs, 'Job tracking status');\n } catch (e) {\n result = error(`Failed to read job status: ${e.message}`, 500);\n }\n }\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // STATS - Dashboard statistics\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (base === 'stats') {\n const db = new Database(db_path, { readonly: true });\n try {\n // Consolidated stats queries (7 queries â†’ 2 queries)\n const entityCounts = db.prepare(`\n SELECT\n (SELECT COUNT(*) FROM clients WHERE is_active = 1) as clients,\n (SELECT COUNT(*) FROM batches) as batches,\n (SELECT COUNT(*) FROM accounts WHERE is_active = 1) as accounts\n `).get();\n \n const contentStats = db.prepare(`\n SELECT\n COUNT(*) as total,\n SUM(CASE WHEN status = 'PENDING' THEN 1 ELSE 0 END) as pending,\n SUM(CASE WHEN status = 'NEEDS_AI' THEN 1 ELSE 0 END) as needs_ai,\n SUM(CASE WHEN status = 'NEEDS_REVIEW' THEN 1 ELSE 0 END) as needs_review,\n SUM(CASE WHEN status = 'APPROVED' THEN 1 ELSE 0 END) as approved,\n SUM(CASE WHEN status = 'SCHEDULED' THEN 1 ELSE 0 END) as scheduled,\n SUM(CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END) as failed\n FROM content_items\n `).get();\n \n const stats = {\n clients: entityCounts.clients,\n batches: entityCounts.batches,\n content_items: {\n total: contentStats.total || 0,\n pending: contentStats.pending || 0,\n needs_ai: contentStats.needs_ai || 0,\n needs_review: contentStats.needs_review || 0,\n approved: contentStats.approved || 0,\n scheduled: contentStats.scheduled || 0,\n failed: contentStats.failed || 0\n },\n accounts: entityCounts.accounts\n };\n result = success(stats, 'Dashboard statistics');\n } finally {\n db.close();\n }\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // CLIENTS - CRUD operations\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (base === 'clients') {\n // POST /clients - Create new client\n if (method === 'POST' && parts.length === 1) {\n const { name, slug, type, language, timezone, instagram_account_id, tiktok_account_id, video_ai_captions, photo_ai_captions, late_profile_id } = body;\n \n if (!name || !slug) {\n result = error('name and slug are required', 400);\n  } else {\n const db = new Database(db_path);\n db.pragma('foreign_keys = ON');\n \n try {\n // Check if exists\n const existing = db.prepare('SELECT id FROM clients WHERE slug = ?').get(slug);\n \n if (existing) {\n result = error(`Client already exists: ${slug}`, 409);\n } else {\n const info = db.prepare(`\n INSERT INTO clients (slug, name, type, language, timezone, is_active, video_ai_captions, photo_ai_captions, late_profile_id, created_at)\n VALUES (?, ?, ?, ?, ?, 1, ?, ?, ?, datetime('now'))\n `).run(slug, name, type || 'business', language || 'en', timezone || 'Europe/Berlin', video_ai_captions ? 1 : 0, photo_ai_captions !== undefined ? (photo_ai_captions ? 1 : 0) : 1, late_profile_id || null);\n \n // Create client folder\n const _clientDir = '/data/clients/' + slug;\n if (!require('fs').existsSync(_clientDir)) {\n   require('fs').mkdirSync(_clientDir, { recursive: true });\n }\n\n // Add accounts if provided\n let igUsername = '';\n let ttUsername = '';\n\n if (instagram_account_id) {\n igUsername = lookupAccountUsername(instagram_account_id, config_base);\n db.prepare(`\n INSERT INTO accounts (client_id, platform, late_account_id, username, is_default, is_active, created_at)\n VALUES (?, 'instagram', ?, ?, 1, 1, datetime('now'))\n `).run(info.lastInsertRowid, instagram_account_id, igUsername);\n }\n if (tiktok_account_id) {\n ttUsername = lookupAccountUsername(tiktok_account_id, config_base);\n db.prepare(`\n INSERT INTO accounts (client_id, platform, late_account_id, username, is_default, is_active, created_at)\n VALUES (?, 'tiktok', ?, ?, 1, 1, datetime('now'))\n `).run(info.lastInsertRowid, tiktok_account_id, ttUsername);\n }\n\n // Link all accounts from Late profile (v17.4)\n if (late_profile_id && !instagram_account_id && !tiktok_account_id) {\n const profileAccounts = lookupProfileAccounts(late_profile_id, config_base);\n for (const acc of profileAccounts) {\n const isDefault = acc.platform === 'instagram' ? 1 : 0;\n db.prepare(`\n INSERT OR IGNORE INTO accounts (client_id, platform, late_account_id, username, display_name, profile_picture_url, is_default, is_active, created_at)\n VALUES (?, ?, ?, ?, ?, ?, ?, 1, datetime('now'))\n `).run(info.lastInsertRowid, acc.platform, acc.id, acc.username, acc.display_name, acc.profile_picture, isDefault);\n\n // Store username for response\n if (acc.platform === 'instagram') igUsername = acc.username;\n if (acc.platform === 'tiktok') ttUsername = acc.username;\n }\n }\n \n // Log audit\n db.prepare(`\n INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n VALUES ('client', ?, 'create', ?, datetime('now'))\n `).run(info.lastInsertRowid, body.user_id || 'api');\n \n const client = db.prepare('SELECT * FROM clients WHERE id = ?').get(info.lastInsertRowid);\n client.hashtags = JSON.parse(client.hashtags || '[]');\n client.platform_defaults = JSON.parse(client.platform_defaults || '{}');\n client.policy = JSON.parse(client.policy || '{}');\n\n // Build accounts object with usernames from cache\n client.accounts = {};\n if (instagram_account_id) {\n client.accounts.instagram = { late_account_id: instagram_account_id, username: igUsername || '' };\n }\n if (tiktok_account_id) {\n client.accounts.tiktok = { late_account_id: tiktok_account_id, username: ttUsername || '' };\n }\n\n // Create client folder structure automatically\n                const clientFolder = `/data/clients/${slug}`;\n                const monthNames = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\n                const currentMonth = monthNames[new Date().getMonth()];\n                const batchFolder = `${clientFolder}/${currentMonth}`;\n\n                // Create folders (recursive handles existing folders gracefully)\n                fs.mkdirSync(`${batchFolder}/photos`, { recursive: true });\n                fs.mkdirSync(`${batchFolder}/videos`, { recursive: true });\n                console.log(`[API] ✓ Created client folder: ${clientFolder}/${currentMonth}/[photos,videos]`);\n\n                // v17.5: Create batch record in database for the month folder\n                try {\n                  db.prepare(`\n                    INSERT INTO batches (client_id, slug, name, description, folder_path, source_type, status, created_at)\n                    VALUES (?, ?, ?, ?, ?, 'folder', 'draft', datetime('now'))\n                  `).run(\n                    result.lastInsertRowid,\n                    currentMonth,\n                    currentMonth.charAt(0).toUpperCase() + currentMonth.slice(1) + ' Content',\n                    'Auto-created batch for ' + currentMonth,\n                    batchFolder\n                  );\n                  console.log(`[API] ✓ Created batch record: ${currentMonth}`);\n                } catch (batchErr) {\n                  // Batch might already exist if folder existed, that's ok\n                  if (!batchErr.message.includes('UNIQUE constraint')) {\n                    console.log(`[API] ⚠ Could not create batch record: ${batchErr.message}`);\n                  }\n                }\n\n                result = success(client, 'Client created');\n }\n } finally {\n db.close();\n }\n }\n }\n // PUT /clients/:slug - Update client\n else if (method === 'PUT' && parts.length === 2) {\n const slug = parts[1];\n const db = new Database(db_path);\n db.pragma('foreign_keys = ON');\n \n try {\n const client = db.prepare('SELECT * FROM clients WHERE slug = ?').get(slug);\n \n if (!client) {\n result = error(`Client not found: ${slug}`, 404);\n } else {\n const updates = [];\n const params = [];\n \n if (body.name !== undefined) { updates.push('name = ?'); params.push(body.name); }\n if (body.type !== undefined) { updates.push('type = ?'); params.push(body.type); }\n if (body.language !== undefined) { updates.push('language = ?'); params.push(body.language); }\n if (body.timezone !== undefined) { updates.push('timezone = ?'); params.push(body.timezone); }\n if (body.is_active !== undefined) { updates.push('is_active = ?'); params.push(body.is_active ? 1 : 0); }\n if (body.video_ai_captions !== undefined) { updates.push('video_ai_captions = ?'); params.push(body.video_ai_captions ? 1 : 0); }\n    if (body.photo_ai_captions !== undefined) { updates.push('photo_ai_captions = ?'); params.push(body.photo_ai_captions ? 1 : 0); }\n if (body.ai_generated !== undefined) { updates.push('ai_generated = ?'); params.push(body.ai_generated ? 1 : 0); }\n if (body.onboarding_data !== undefined) { updates.push('onboarding_data = ?'); params.push(JSON.stringify(body.onboarding_data)); }\n if (body.brand_description !== undefined) { updates.push('brand_description = ?'); params.push(body.brand_description); }\n if (body.brand_target_audience !== undefined) { updates.push('brand_target_audience = ?'); params.push(body.brand_target_audience); }\n if (body.brand_voice !== undefined) { updates.push('brand_voice = ?'); params.push(body.brand_voice); }\n if (body.hashtags !== undefined) { updates.push('hashtags = ?'); params.push(JSON.stringify(body.hashtags)); }\n if (body.platform_defaults !== undefined) { updates.push('platform_defaults = ?'); params.push(JSON.stringify(body.platform_defaults)); }\n if (body.policy !== undefined) { updates.push('policy = ?'); params.push(JSON.stringify(body.policy)); }\n\n // Handle late_profile_id update (v17.4)\n if (body.late_profile_id !== undefined) {\n updates.push('late_profile_id = ?');\n params.push(body.late_profile_id || null);\n\n // Relink accounts from new profile\n db.prepare('DELETE FROM accounts WHERE client_id = ?').run(client.id);\n if (body.late_profile_id) {\n const profileAccounts = lookupProfileAccounts(body.late_profile_id, config_base);\n for (const acc of profileAccounts) {\n const isDefault = acc.platform === 'instagram' ? 1 : 0;\n db.prepare(`\n INSERT INTO accounts (client_id, platform, late_account_id, username, display_name, profile_picture_url, is_default, is_active, created_at)\n VALUES (?, ?, ?, ?, ?, ?, ?, 1, datetime('now'))\n `).run(client.id, acc.platform, acc.id, acc.username, acc.display_name, acc.profile_picture, isDefault);\n }\n }\n }\n \n if (updates.length > 0) {\n params.push(client.id);\n db.prepare(`UPDATE clients SET ${updates.join(', ')} WHERE id = ?`).run(...params);\n \n // Log audit\n db.prepare(`\n INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n VALUES ('client', ?, 'update', ?, datetime('now'))\n `).run(client.id, body.user_id || 'api');\n }\n \n const updated = db.prepare('SELECT * FROM clients WHERE id = ?').get(client.id);\n updated.hashtags = JSON.parse(updated.hashtags || '[]');\n updated.platform_defaults = JSON.parse(updated.platform_defaults || '{}');\n updated.policy = JSON.parse(updated.policy || '{}');\n \n result = success(updated, 'Client updated');\n }\n } finally {\n db.close();\n }\n }\n // DELETE /clients/:slug - DELETE /clients - Delete all clients\n else if (method === 'DELETE' && parts.length === 1) {\n const db = new Database(db_path);\n db.pragma('foreign_keys = ON');\n\n try {\n const clients = db.prepare('SELECT id, slug FROM clients WHERE is_active = 1').all();\n const count = clients.length;\n\n if (count === 0) {\n result = success({ deleted: 0 }, 'No clients to delete');\n } else {\n // Delete related data first (foreign key constraints)\n const clientIds = clients.map(c => c.id);\n const placeholders = clientIds.map(() => '?').join(',');\n\n // Delete accounts for these clients\n db.prepare(`DELETE FROM accounts WHERE client_id IN (${placeholders})`).run(...clientIds);\n\n // Delete batches and content items for these clients\n const batches = db.prepare(`SELECT id FROM batches WHERE client_id IN (${placeholders})`).all(...clientIds);\n if (batches.length > 0) {\n const batchIds = batches.map(b => b.id);\n const batchPlaceholders = batchIds.map(() => '?').join(',');\n db.prepare(`DELETE FROM content_items WHERE batch_id IN (${batchPlaceholders})`).run(...batchIds);\n db.prepare(`DELETE FROM batches WHERE id IN (${batchPlaceholders})`).run(...batchIds);\n }\n\n // Delete the clients\n db.prepare(`DELETE FROM clients WHERE id IN (${placeholders})`).run(...clientIds);\n\n // Log audit\n db.prepare(`\n INSERT INTO audit_log (entity_type, entity_id, action, details, user_id, created_at)\n VALUES ('client', 0, 'delete_all', ?, ?, datetime('now'))\n `).run(JSON.stringify({ count, slugs: clients.map(c => c.slug) }), body.user_id || 'api');\n\n result = success({ deleted: count, slugs: clients.map(c => c.slug) }, `Deleted ${count} clients`);\n }\n } finally {\n db.close();\n }\n }\n // Hard delete client with full cascade\n else if (method === 'DELETE' && parts.length === 2) {\n const slug = parts[1];\n const db = new Database(db_path);\n db.pragma('foreign_keys = ON');\n \n try {\n const client = db.prepare('SELECT * FROM clients WHERE slug = ?').get(slug);\n \n if (!client) {\n result = error(`Client not found: ${slug}`, 404);\n } else {\n // Use transaction for proper cascade delete\n const deleteClient = db.transaction(() => {\n // Delete in order: files -> content_items -> batches -> accounts -> client\n db.prepare('DELETE FROM files WHERE client_id = ?').run(client.id);\n db.prepare('DELETE FROM content_items WHERE client_id = ?').run(client.id);\n db.prepare('DELETE FROM batches WHERE client_id = ?').run(client.id);\n db.prepare('DELETE FROM accounts WHERE client_id = ?').run(client.id);\n db.prepare('DELETE FROM clients WHERE id = ?').run(client.id);\n });\n deleteClient();\n \n result = success({ slug }, 'Client deleted');\n }\n } finally {\n db.close();\n }\n }\n // GET /clients - List all clients with accounts (optimized: 2 queries instead of N+1)\n else if (parts.length === 1) {\n const db = new Database(db_path, { readonly: true });\n try {\n const clients = db.prepare(`\n SELECT c.*,\n (SELECT COUNT(*) FROM batches WHERE client_id = c.id) as batch_count,\n (SELECT COUNT(*) FROM accounts WHERE client_id = c.id AND is_active = 1) as account_count,\n (SELECT COUNT(*) FROM content_items ci JOIN batches b ON ci.batch_id = b.id WHERE b.client_id = c.id) as item_count\n FROM clients c\n WHERE c.is_active = 1\n ORDER BY c.name\n `).all();\n\n // Fetch ALL accounts in one query, then build a map (eliminates N+1)\n const allAccounts = db.prepare(`\n SELECT client_id, platform, late_account_id, username\n FROM accounts WHERE is_active = 1\n `).all();\n \n const accountMap = {};\n for (const acc of allAccounts) {\n if (!accountMap[acc.client_id]) accountMap[acc.client_id] = {};\n accountMap[acc.client_id][acc.platform] = {\n late_account_id: acc.late_account_id,\n username: acc.username || ''\n };\n }\n\n // Parse JSON fields and attach pre-fetched accounts\n for (const client of clients) {\n client.hashtags = JSON.parse(client.hashtags || '[]');\n client.platform_defaults = JSON.parse(client.platform_defaults || '{}');\n client.policy = JSON.parse(client.policy || '{}');\n client.accounts = accountMap[client.id] || {};\n }\n\n result = success(clients, `Found ${clients.length} clients`);\n } finally {\n db.close();\n }\n }\n // GET /clients/:slug/posts - Get cached scheduled posts (v17.5)\n else if (parts.length === 3 && parts[2] === 'posts' && method === 'GET') {\n const slug = parts[1];\n const postsPath = `/data/clients/${slug}/scheduled_posts.json`;\n\n if (fs.existsSync(postsPath)) {\n try {\n const data = JSON.parse(fs.readFileSync(postsPath, 'utf8'));\n result = success(data, 'Scheduled posts loaded from cache');\n } catch (e) {\n result = error(`Failed to read posts cache: ${e.message}`, 500);\n }\n } else {\n // Return empty data if no cache exists yet\n result = success({\n posts: [],\n synced_at: null,\n total: 0,\n profile_id: null\n }, 'No cached posts - run sync first');\n }\n }\n // GET /clients/:slug - Get single client with accounts\n else if (parts.length === 2) {\n const db = new Database(db_path, { readonly: true });\n try {\n const slug = parts[1];\n const client = db.prepare('SELECT * FROM clients WHERE slug = ?').get(slug);\n\n if (!client) {\n result = error(`Client not found: ${slug}`, 404);\n } else {\n client.hashtags = JSON.parse(client.hashtags || '[]');\n client.platform_defaults = JSON.parse(client.platform_defaults || '{}');\n client.policy = JSON.parse(client.policy || '{}');\n\n // Fetch linked accounts and build accounts object\n const accounts = db.prepare('SELECT * FROM accounts WHERE client_id = ? AND is_active = 1').all(client.id);\n client.accounts = {};\n for (const acc of accounts) {\n client.accounts[acc.platform] = {\n late_account_id: acc.late_account_id,\n username: acc.username || ''\n };\n }\n\n // Include late_profile info if set (v17.4)\n if (client.late_profile_id) {\n client.late_profile = lookupProfile(client.late_profile_id, config_base);\n }\n\n result = success(client);\n }\n } finally {\n db.close();\n }\n }\n // GET /clients/:slug/accounts\n else if (parts.length === 3 && parts[2] === 'accounts') {\n const db = new Database(db_path, { readonly: true });\n try {\n const slug = parts[1];\n const client = db.prepare('SELECT id FROM clients WHERE slug = ?').get(slug);\n \n if (!client) {\n result = error(`Client not found: ${slug}`, 404);\n } else {\n const accounts = db.prepare(`\n SELECT * FROM accounts WHERE client_id = ? ORDER BY platform, is_default DESC\n `).all(client.id);\n result = success(accounts, `Found ${accounts.length} accounts`);\n }\n } finally {\n db.close();\n }\n }\n // GET /clients/:slug/batches - Hybrid filesystem + database\n else if (parts.length === 3 && parts[2] === 'batches') {\n const db = new Database(db_path, { readonly: true });\n try {\n const slug = parts[1];\n const client = db.prepare('SELECT id FROM clients WHERE slug = ?').get(slug);\n \n if (!client) {\n result = error(`Client not found: ${slug}`, 404);\n } else {\n // 1. Scan filesystem for batch folders\n const clientPath = `/data/clients/${slug}`;\n const fsBatches = [];\n\n if (fs.existsSync(clientPath)) {\n const entries = fs.readdirSync(clientPath, { withFileTypes: true });\n for (const entry of entries) {\n if (entry.isDirectory() && !entry.name.startsWith('_') && !entry.name.startsWith('.')) {\n const batchPath = `${clientPath}/${entry.name}`;\n const hasReady = fs.existsSync(`${batchPath}/READY.txt`);\n const hasConfig = fs.existsSync(`${batchPath}/batch_config.yaml`) ||\n fs.existsSync(`${batchPath}/batch.yaml`);\n\n // Count media files\n let photoCount = 0, videoCount = 0;\n const photosPath = `${batchPath}/photos`;\n const videosPath = `${batchPath}/videos`;\n if (fs.existsSync(photosPath)) {\n photoCount = fs.readdirSync(photosPath).filter(f => /.(jpg|jpeg|png)$/i.test(f)).length;\n }\n if (fs.existsSync(videosPath)) {\n videoCount = fs.readdirSync(videosPath).filter(f => /.(mp4|mov)$/i.test(f)).length;\n }\n\n fsBatches.push({\n name: entry.name,\n slug: entry.name,\n has_ready: hasReady,\n has_config: hasConfig,\n photo_count: photoCount,\n video_count: videoCount,\n source: 'filesystem'\n });\n }\n }\n }\n\n // 2. Get database batches with status counts\n const dbBatches = db.prepare(`\n SELECT b.*,\n (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id) as item_count,\n (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id AND status = 'NEEDS_AI') as needs_ai,\n (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id AND status = 'NEEDS_REVIEW') as needs_review,\n (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id AND status = 'APPROVED') as approved,\n (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id AND status = 'SCHEDULED') as scheduled\n FROM batches b WHERE b.client_id = ?\n `).all(client.id);\n\n // 3. Merge: DB data enriches filesystem data\n const merged = fsBatches.map(fsBatch => {\n const dbBatch = dbBatches.find(d => d.slug === fsBatch.name);\n if (dbBatch) {\n return {\n ...fsBatch,\n id: dbBatch.id,\n ingested: true,\n item_count: dbBatch.item_count,\n needs_ai: dbBatch.needs_ai || 0,\n needs_review: dbBatch.needs_review || 0,\n approved: dbBatch.approved || 0,\n scheduled: dbBatch.scheduled || 0,\n source: 'database'\n };\n }\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// ═══════════════════════════════════════════════════════════════════════════════\n// LATE API ENDPOINTS (v17.9)\n// ═══════════════════════════════════════════════════════════════════════════════\n\n// GET /late/status - Check if Late API is configured\nif (parts[0] === 'late' && parts[1] === 'status' && method === 'GET') {\n const configBase = '/data/clients/_config';\n const dbPath = `${configBase}/socialflow.db`;\n\n try {\n const db = new Database(dbPath);\n db.pragma('foreign_keys = ON');\n\n const config = db.prepare('SELECT plan_name, connected_at, synced_at FROM late_config WHERE id = 1').get();\n db.close();\n\n if (!config) {\n return { success: true, data: { configured: false } };\n }\n\n return {\n success: true,\n data: {\n configured: true,\n plan_name: config.plan_name,\n connected_at: config.connected_at,\n synced_at: config.synced_at\n }\n };\n } catch (e) {\n return { success: true, data: { configured: false } };\n }\n}\n\n// POST /late/connect - Store API key (validation happens on sync)\nif (parts[0] === 'late' && parts[1] === 'connect' && method === 'POST') {\n const { api_key } = body;\n\n if (!api_key || typeof api_key !== 'string' || !api_key.trim()) {\n return { success: false, error: 'API key is required' };\n }\n\n const trimmedKey = api_key.trim();\n\n if (!trimmedKey.startsWith('sk_')) {\n return { success: false, error: 'Invalid API key format. Key should start with sk_', error_code: 'INVALID_FORMAT' };\n }\n\n try {\n const configBase = '/data/clients/_config';\n const dbPath = `${configBase}/socialflow.db`;\n\n const db = new Database(dbPath);\n db.pragma('foreign_keys = ON');\n\n db.exec(`\n CREATE TABLE IF NOT EXISTS late_config (\n id INTEGER PRIMARY KEY CHECK (id = 1),\n api_key TEXT NOT NULL,\n plan_name TEXT,\n connected_at TEXT,\n synced_at TEXT,\n updated_at TEXT DEFAULT (datetime('now'))\n )\n `);\n\n const now = new Date().toISOString();\n\n db.prepare(`\n INSERT INTO late_config (id, api_key, plan_name, connected_at, updated_at)\n VALUES (1, ?, ?, ?, ?)\n ON CONFLICT(id) DO UPDATE SET\n api_key = excluded.api_key,\n plan_name = excluded.plan_name,\n connected_at = excluded.connected_at,\n updated_at = excluded.updated_at\n `).run(trimmedKey, 'Pending Sync', now, now);\n\n db.close();\n\n console.log('[API] Late API key stored - pending sync validation');\n\n return {\n success: true,\n message: 'API key saved. Click Sync to validate and fetch profiles.',\n data: {\n plan_name: 'Pending Sync',\n connected_at: now\n }\n };\n } catch (e) {\n console.log('[API] Late connect error:', e.message);\n return {\n success: false,\n error: `Failed to save API key: ${e.message}`,\n error_code: 'DB_ERROR'\n };\n }\n}\n\n// POST /late/sync - Sync profiles and accounts (reads from cache written by W0)\nif (parts[0] === 'late' && parts[1] === 'sync' && method === 'POST') {\n const configBase = '/data/clients/_config';\n const dbPath = `${configBase}/socialflow.db`;\n const cachePath = `${configBase}/late_accounts.json`;\n\n try {\n const db = new Database(dbPath);\n db.pragma('foreign_keys = ON');\n\n const config = db.prepare('SELECT api_key FROM late_config WHERE id = 1').get();\n\n if (!config || !config.api_key) {\n db.close();\n return { success: false, error: 'Not connected to Late.com. Enter your API key first.', error_code: 'NOT_CONNECTED' };\n }\n\n db.close();\n\n // Check if cache exists (W0 should have synced)\n if (fs.existsSync(cachePath)) {\n const cache = JSON.parse(fs.readFileSync(cachePath, 'utf8'));\n\n // Update plan name and sync time\n const db2 = new Database(dbPath);\n const nowISO = new Date().toISOString();\n db2.prepare('UPDATE late_config SET plan_name = ?, synced_at = ?, updated_at = ? WHERE id = 1').run('Connected', nowISO, nowISO);\n db2.close();\n\n return {\n success: true,\n workflow: 'W0',\n message: 'Sync completed successfully',\n data: {\n profiles_count: (cache.profiles || []).length,\n accounts_count: (cache.accounts || []).length,\n synced_at: cache.synced_at || nowISO,\n profiles: (cache.profiles || []).map(p => ({\n late_profile_id: p.id,\n name: p.name,\n color: p.color,\n accounts_count: (cache.accounts || []).filter(a => getAccountProfileId(a) === p.id).length\n }))\n }\n };\n }\n\n return {\n success: false,\n error: 'No sync data found. Please trigger W0 sync workflow first.',\n error_code: 'NO_CACHE'\n };\n } catch (e) {\n console.log('[API] Late sync error:', e.message);\n return {\n success: false,\n workflow: 'W0',\n error: `Sync failed: ${e.message}`,\n error_code: 'SYNC_ERROR'\n };\n }\n}\n\n// GET /late/profiles - Get cached profiles\nif (parts[0] === 'late' && parts[1] === 'profiles' && method === 'GET') {\n const configBase = '/data/clients/_config';\n const cachePath = `${configBase}/late_accounts.json`;\n\n try {\n if (!fs.existsSync(cachePath)) {\n return { success: true, data: { profiles: [], synced_at: null } };\n }\n\n const cache = JSON.parse(fs.readFileSync(cachePath, 'utf8'));\n\n return {\n success: true,\n data: {\n profiles: (cache.profiles || []).map(p => ({\n late_profile_id: p.id,\n name: p.name,\n color: p.color,\n is_default: p.is_default,\n accounts_count: (cache.accounts || []).filter(a => getAccountProfileId(a) === p.id).length\n })),\n synced_at: cache.synced_at || null\n }\n };\n } catch (e) {\n return { success: true, data: { profiles: [], synced_at: null } };\n }\n}\n\n// POST /late/disconnect - Remove API key\nif (parts[0] === 'late' && parts[1] === 'disconnect' && method === 'POST') {\n const configBase = '/data/clients/_config';\n const dbPath = `${configBase}/socialflow.db`;\n\n try {\n const db = new Database(dbPath);\n db.prepare('DELETE FROM late_config WHERE id = 1').run();\n db.close();\n\n console.log('[API] Late API key disconnected');\n\n return { success: true, message: 'Disconnected from Late.com' };\n } catch (e) {\n return { success: false, error: e.message };\n }\n}\n\n\nreturn { ...fsBatch, ingested: false, item_count: 0, needs_ai: 0, needs_review: 0, approved: 0, scheduled: 0 };\n });\n\n result = success({ batches: merged, client: slug }, `Found ${merged.length} batches`);\n }\n } finally {\n db.close();\n }\n }\n else {\n result = error(`Invalid clients route: ${route}`, 400);\n }\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // FILES - List uploaded files for a batch (v17)\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (base === 'files') {\n const db = new Database(db_path, { readonly: true });\n try {\n // GET /files/:batch_id - List files for a batch\n if (parts.length === 2) {\n const batchId = parts[1];\n const files = db.prepare(`\n SELECT * FROM files WHERE batch_id = ? ORDER BY uploaded_at ASC\n `).all(batchId);\n result = success({ files }, `Found ${files.length} files`);\n } else {\n result = error('Batch ID required', 400);\n }\n } finally {\n db.close();\n }\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // BATCHES - Get batch details, list batches, status counts\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n\n  // PUT /item/:id/platforms - Update item platforms (v17.8)\n  else if (method === 'PUT' && parts.length === 3 && parts[0] === 'item' && parts[2] === 'platforms') {\n    const itemId = parseInt(parts[1]);\n    const { platforms } = body;\n\n    if (!itemId || isNaN(itemId)) {\n      result = error('Invalid item ID', 400);\n    } else if (!platforms || !['ig', 'tt', 'ig,tt', 'tt,ig'].includes(platforms.toLowerCase())) {\n      result = error('Invalid platforms. Use: ig, tt, or ig,tt', 400);\n    } else {\n      const db = new Database(db_path);\n      try {\n        // Normalize platforms (sort alphabetically)\n        const normalizedPlatforms = platforms.toLowerCase().split(',').sort().join(',');\n\n        const existing = db.prepare('SELECT id FROM content_items WHERE id = ?').get(itemId);\n        if (!existing) {\n          result = error('Item not found', 404);\n        } else {\n          db.prepare('UPDATE content_items SET platforms = ? WHERE id = ?')\n            .run(normalizedPlatforms, itemId);\n\n          const updated = db.prepare('SELECT id, platforms FROM content_items WHERE id = ?').get(itemId);\n          result = success(updated, 'Platforms updated');\n        }\n      } finally {\n        db.close();\n      }\n    }\n  }\n\n else if (base === 'batches') {\n // POST /batches - Create new batch for upload-based onboarding (v17)\n if (method === 'POST' && parts.length === 1) {\n const { client_id, name, description, source_type } = body;\n \n if (!client_id || !name) {\n result = error('client_id and name required', 400);\n } else {\n const dbWrite = new Database(db_path);\n dbWrite.pragma('foreign_keys = ON');\n \n try {\n // Verify client exists\n const client = dbWrite.prepare('SELECT id, slug FROM clients WHERE id = ?').get(client_id);\n if (!client) {\n result = error(`Client not found: ${client_id}`, 404);\n } else {\n // Generate slug from name\n const slug = name.toLowerCase()\n .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n .replace(/[^a-z0-9]+/g, '-')\n .replace(/^-|-$/g, '');\n \n // Check if batch exists\n const existing = dbWrite.prepare('SELECT id FROM batches WHERE client_id = ? AND slug = ?').get(client_id, slug);\n if (existing) {\n result = error(`Batch already exists: ${slug}`, 409);\n } else {\n const info = dbWrite.prepare(`\n INSERT INTO batches (client_id, slug, name, description, source_type, status, created_at)\n VALUES (?, ?, ?, ?, ?, 'draft', datetime('now'))\n `).run(client_id, slug, name, description || '', source_type || 'upload');\n \n result = success({ batch_id: info.lastInsertRowid, slug, client_slug: client.slug }, 'Batch created');\n }\n }\n } finally {\n dbWrite.close();\n }\n }\n}\n  // PUT /batches/:client/:batch - Update batch settings (v17.8)\n  else if (method === 'PUT' && parts.length === 3) {\n    const clientSlug = parts[1];\n    const batchSlug = parts[2];\n    const { video_ai_captions, photo_ai_captions, schedule_config, brief, description } = body;\n\n    const dbWrite = new Database(db_path);\n    dbWrite.pragma('foreign_keys = ON');\n\n    try {\n      // Find the batch\n      const batch = dbWrite.prepare(`\n        SELECT b.id FROM batches b\n        JOIN clients c ON b.client_id = c.id\n        WHERE c.slug = ? AND b.slug = ?\n      `).get(clientSlug, batchSlug);\n\n      if (!batch) {\n        result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n      } else {\n        // Build dynamic UPDATE query\n        const updates = [];\n        const values = [];\n\n        if (video_ai_captions !== undefined) {\n          updates.push('video_ai_captions = ?');\n          values.push(video_ai_captions);\n        }\n        if (photo_ai_captions !== undefined) {\n          updates.push('photo_ai_captions = ?');\n          values.push(photo_ai_captions);\n        }\n        if (schedule_config !== undefined) {\n          updates.push('schedule_config = ?');\n          values.push(typeof schedule_config === 'string' ? schedule_config : JSON.stringify(schedule_config));\n        }\n        if (brief !== undefined) {\n          updates.push('brief = ?');\n          values.push(brief);\n        }\n        if (description !== undefined) {\n          updates.push('description = ?');\n          values.push(description);\n        }\n\n        if (updates.length === 0) {\n          result = error('No valid fields to update', 400);\n        } else {\n          values.push(batch.id);\n          dbWrite.prepare(`UPDATE batches SET ${updates.join(', ')} WHERE id = ?`).run(...values);\n\n          // Return updated batch\n          const updated = dbWrite.prepare('SELECT * FROM batches WHERE id = ?').get(batch.id);\n          result = success(updated, 'Batch updated');\n        }\n      }\n    } finally {\n      dbWrite.close();\n    }\n  }\n  // ─────────────────────────────────────────────────────────────\n  // POST /batches/:client/:batch/schedule - Bulk update content schedules (v17)\n  // ─────────────────────────────────────────────────────────────\n  else if (method === 'POST' && parts.length === 4 && parts[3] === 'schedule') {\n    const clientSlug = parts[1];\n    const batchSlug = parts[2];\n    const db = new Database(db_path);\n    db.pragma('foreign_keys = ON');\n\n    try {\n      const batch = db.prepare(`\n        SELECT b.id FROM batches b\n        JOIN clients c ON b.client_id = c.id\n        WHERE c.slug = ? AND b.slug = ?\n      `).get(clientSlug, batchSlug);\n\n      if (!batch) {\n        result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n      } else if (!Array.isArray(body.items) || body.items.length === 0) {\n        result = error('items array is required', 400);\n      } else {\n        // Validate all schedule items before processing\n        try {\n          for (const item of body.items) {\n            validateScheduleItem(item);\n          }\n        } catch (validationError) {\n          result = error(validationError.message, 400);\n          db.close();\n          return [{ json: result }];\n        }\n\n        const timezone = body.timezone || 'Europe/Berlin';\n        const updateStmt = db.prepare(`\n          UPDATE content_items\n          SET scheduled_date = ?,\n              scheduled_time = ?,\n              schedule_at = ?,\n              slot = ?,\n              updated_at = datetime('now')\n          WHERE (id = ? OR content_id = ?)\n            AND batch_id = ?\n            AND status IN ('APPROVED', 'SCHEDULED')\n        `);\n\n        let updated = 0;\n        const updateMany = db.transaction((items) => {\n          for (const item of items) {\n            const scheduleAt = `${item.scheduled_date}T${item.scheduled_time}`;\n            const info = updateStmt.run(\n              item.scheduled_date,\n              item.scheduled_time,\n              scheduleAt,\n              item.slot || 'feed',\n              item.id, String(item.id),\n              batch.id\n            );\n            if (info.changes > 0) updated++;\n          }\n        });\n\n        updateMany(body.items);\n\n        result = success({ updated, total: body.items.length }, `Updated schedule for ${updated} items`);\n      }\n    } finally {\n      db.close();\n    }\n  }\n  else {\n const db = new Database(db_path, { readonly: true });\n try {\n // GET /batches/:client/:batch/generation-progress - Get AI generation progress (v15)\n if (parts.length === 4 && parts[3] === 'generation-progress') {\n const clientSlug = parts[1];\n const batchSlug = parts[2];\n \n const batch = db.prepare(`\n SELECT b.id, b.generation_progress, b.generation_started_at FROM batches b\n JOIN clients c ON b.client_id = c.id\n WHERE c.slug = ? AND b.slug = ?\n `).get(clientSlug, batchSlug);\n \n if (!batch) {\n result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n } else {\n let progress = null;\n if (batch.generation_progress) {\n try {\n progress = JSON.parse(batch.generation_progress);\n } catch (e) {\n progress = null;\n }\n }\n result = success({\n progress: progress,\n started_at: batch.generation_started_at,\n is_running: progress !== null\n }, progress ? `Generating item ${progress.current}/${progress.total}` : 'No generation in progress');\n }\n }\n // GET /batches/:client/:batch/ingest-progress - Get W1 ingest progress (v15.2)\n else if (parts.length === 4 && parts[3] === 'ingest-progress') {\n const clientSlug = parts[1];\n const batchSlug = parts[2];\n \n const batch = db.prepare(`\n SELECT b.id, b.ingest_progress, b.ingest_started_at FROM batches b\n JOIN clients c ON b.client_id = c.id\n WHERE c.slug = ? AND b.slug = ?\n `).get(clientSlug, batchSlug);\n \n if (!batch) {\n result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n } else {\n let progress = null;\n if (batch.ingest_progress) {\n try {\n progress = JSON.parse(batch.ingest_progress);\n } catch (e) {\n progress = null;\n }\n }\n result = success({\n progress: progress,\n started_at: batch.ingest_started_at,\n is_running: progress !== null\n }, progress ? `Processing ${progress.current}/${progress.total} (${progress.stage})` : 'No ingest in progress');\n }\n }\n // GET /batches/:client/:batch/status - Get status counts for batch\n else if (parts.length === 4 && parts[3] === 'status') {\n const clientSlug = parts[1];\n const batchSlug = parts[2];\n \n const batch = db.prepare(`\n SELECT b.id FROM batches b\n JOIN clients c ON b.client_id = c.id\n WHERE c.slug = ? AND b.slug = ?\n `).get(clientSlug, batchSlug);\n \n if (!batch) {\n result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n } else {\n const counts = db.prepare(`\n SELECT\n COUNT(*) as total,\n SUM(CASE WHEN status = 'PENDING' THEN 1 ELSE 0 END) as pending,\n SUM(CASE WHEN status = 'NEEDS_AI' THEN 1 ELSE 0 END) as needs_ai,\n SUM(CASE WHEN status = 'NEEDS_REVIEW' THEN 1 ELSE 0 END) as needs_review,\n SUM(CASE WHEN status = 'APPROVED' THEN 1 ELSE 0 END) as approved,\n SUM(CASE WHEN status = 'SCHEDULED' THEN 1 ELSE 0 END) as scheduled,\n SUM(CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END) as failed\n FROM content_items WHERE batch_id = ?\n `).get(batch.id);\n result = success({ counts, client: clientSlug, batch: batchSlug });\n }\n }\n // GET /batches/:client/:batch - Get batch details\n else if (parts.length === 3) {\n const clientSlug = parts[1];\n const batchSlug = parts[2];\n \n const batch = db.prepare(`\n SELECT b.*, c.slug as client_slug, c.name as client_name\n FROM batches b\n JOIN clients c ON b.client_id = c.id\n WHERE c.slug = ? AND b.slug = ?\n `).get(clientSlug, batchSlug);\n \n if (!batch) {\n result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n } else {\n batch.hashtags = JSON.parse(batch.hashtags || '[]');\n batch.schedule_config = JSON.parse(batch.schedule_config || '{}');\n result = success(batch);\n }\n }\n // GET /batches/:client - List all batches for a client\n else if (parts.length === 2) {\n const clientSlug = parts[1];\n const client = db.prepare('SELECT id FROM clients WHERE slug = ?').get(clientSlug);\n \n if (!client) {\n result = error(`Client not found: ${clientSlug}`, 404);\n } else {\n const batches = db.prepare(`\n SELECT b.*,\n (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id) as item_count,\n (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id AND status = 'NEEDS_REVIEW') as pending_review\n FROM batches b\n WHERE b.client_id = ?\n ORDER BY b.created_at DESC\n `).all(client.id);\n \n for (const batch of batches) {\n batch.hashtags = JSON.parse(batch.hashtags || '[]');\n batch.schedule_config = JSON.parse(batch.schedule_config || '{}');\n }\n \n result = success({ batches, client: clientSlug }, `Found ${batches.length} batches`);\n }\n }\n else {\n result = error('Invalid batch route', 400);\n }\n } finally {\n db.close();\n }\n }\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // ITEMS - Get content items for approval board\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (base === 'items') {\n const db = new Database(db_path, { readonly: true });\n try {\n // GET /items/:client/:batch/:content_id/conversations - Get AI conversation logs (v15)\n if (parts.length === 5 && parts[4] === 'conversations') {\n const clientSlug = parts[1];\n const batchSlug = parts[2];\n const contentId = parts[3];\n \n // Verify the content item exists\n const item = db.prepare(`\n SELECT ci.id, ci.content_id FROM content_items ci\n JOIN clients c ON ci.client_id = c.id\n JOIN batches b ON ci.batch_id = b.id\n WHERE c.slug = ? AND b.slug = ? AND ci.content_id = ?\n `).get(clientSlug, batchSlug, contentId);\n \n if (!item) {\n result = error(`Content item not found: ${clientSlug}/${batchSlug}/${contentId}`, 404);\n } else {\n const conversations = db.prepare(`\n SELECT * FROM ai_conversations\n WHERE content_id = ?\n ORDER BY session_id, round_number, role\n `).all(contentId);\n \n // Group by session for easier UI display\n const sessions = {};\n for (const conv of conversations) {\n if (!sessions[conv.session_id]) {\n sessions[conv.session_id] = {\n session_id: conv.session_id,\n rounds: []\n };\n }\n sessions[conv.session_id].rounds.push(conv);\n }\n \n result = success({\n content_id: contentId,\n sessions: Object.values(sessions),\n total_conversations: conversations.length\n }, `Found ${conversations.length} conversation entries`);\n }\n }\n // GET /items/:client/:batch - List items\n else if (parts.length >= 3) {\n const clientSlug = parts[1];\n const batchSlug = parts[2];\n const statusFilter = query.status || null;\n const rawLimit = parseInt(query.limit || '100', 10);\n const rawOffset = parseInt(query.offset || '0', 10);\n // Bounds checking: limit 1-1000, offset >= 0\n const limit = Math.min(1000, Math.max(1, isNaN(rawLimit) ? 100 : rawLimit));\n const offset = Math.max(0, isNaN(rawOffset) ? 0 : rawOffset);\n \n // Validate status filter (whitelist to prevent SQL injection)\n if (statusFilter && !VALID_STATUSES.includes(statusFilter)) {\n result = error(`Invalid status filter: ${statusFilter}. Valid values: ${VALID_STATUSES.join(', ')}`, 400);\n db.close();\n return [{ json: result }];\n }\n \n // Load current Cloudflare URL for dynamic URL reconstruction\n const settingsPath = `${config_base}/settings.json`;\n let cloudflareUrl = '';\n try {\n if (fs.existsSync(settingsPath)) {\n const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n cloudflareUrl = settings.cloudflare_tunnel_url || '';\n }\n } catch (e) {\n console.log('[API] Warning: Could not load Cloudflare URL from settings');\n }\n \n let queryStr = `\n SELECT ci.*, c.slug as client_slug, b.slug as batch_slug,\n b.source_type, f.storage_path as upload_path, f.uuid as file_uuid\n FROM content_items ci\n JOIN clients c ON ci.client_id = c.id\n JOIN batches b ON ci.batch_id = b.id\n LEFT JOIN files f ON ci.file_id = f.id\n WHERE c.slug = ? AND b.slug = ? AND ci.status != 'DELETED'\n `;\n const params = [clientSlug, batchSlug];\n \n if (statusFilter) {\n queryStr += ' AND ci.status = ?';\n params.push(statusFilter);\n }\n \n queryStr += ' ORDER BY ci.scheduled_date, ci.scheduled_time LIMIT ? OFFSET ?';\n params.push(limit, offset);\n \n const items = db.prepare(queryStr).all(...params);\n \n // Rebuild media URLs with current Cloudflare URL (v17: source_type aware)\n if (cloudflareUrl) {\n for (const item of items) {\n const cacheBuster = item.file_hash ? `?v=${item.file_hash.substring(0, 8)}` : `?t=${Date.now()}`;\n if (item.source_type === 'upload' && item.upload_path) {\n // Upload-based batch: serve from /uploads/ directory\n const ext = item.file_name ? item.file_name.match(/\\.[^.]+$/)?.[0] || '' : '';\n item.media_url = `${cloudflareUrl}/uploads/${item.client_id}/${item.batch_id}/${item.file_uuid}${ext}${cacheBuster}`;\n } else {\n // Folder-based batch: serve from /{client}/{batch}/photos|videos/\n const mediaFolder = item.media_type === 'photo' ? 'photos' : 'videos';\n item.media_url = `${cloudflareUrl}/${item.client_slug}/${item.batch_slug}/${mediaFolder}/${item.file_name}${cacheBuster}`;\n }\n item.preview_url = item.media_url;\n }\n }\n \n // Get total count\n let countQuery = `\n SELECT COUNT(*) as total\n FROM content_items ci\n JOIN clients c ON ci.client_id = c.id\n JOIN batches b ON ci.batch_id = b.id\n WHERE c.slug = ? AND b.slug = ? AND ci.status != 'DELETED'\n `;\n const countParams = [clientSlug, batchSlug];\n if (statusFilter) {\n countQuery += ' AND ci.status = ?';\n countParams.push(statusFilter);\n }\n const totalCount = db.prepare(countQuery).get(...countParams).total;\n \n result = success({\n items: items,\n pagination: {\n total: totalCount,\n limit: limit,\n offset: offset,\n has_more: offset + items.length < totalCount\n }\n }, `Found ${items.length} items`);\n } else {\n result = error('Items route requires client and batch slug', 400);\n }\n } finally {\n db.close();\n }\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // ITEM - Single item operations\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (base === 'item') {\n if (parts.length < 2) {\n result = error('Item ID required', 400);\n } else {\n const itemId = parts[1];\n const action = parts[2] || null;\n \n const db = new Database(db_path);\n db.pragma('foreign_keys = ON');\n \n try {\n // Get item by ID or content_id\n let item = db.prepare('SELECT * FROM content_items WHERE id = ? OR content_id = ?').get(itemId, itemId);\n \n if (!item) {\n result = error(`Item not found: ${itemId}`, 404);\n }\n // DELETE /item/:id - Soft delete item\n else if (!action && method === 'DELETE') {\n db.prepare(\"UPDATE content_items SET status = 'DELETED' WHERE id = ?\").run(item.id);\n \n db.prepare(`\n INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n VALUES ('content_item', ?, 'delete', ?, datetime('now'))\n `).run(item.id, body.user_id || 'api');\n \n result = success({ id: item.id }, 'Item deleted');\n }\n // GET /item/:id - Return item\n else if (!action) {\n result = success(item);\n }\n // POST /item/:id/approve\n else if (action === 'approve' && method === 'POST') {\n const fileHash = item.file_hash || '';\n \n db.prepare(`\n UPDATE content_items\n SET status = 'APPROVED',\n approved_at = datetime('now'),\n approved_by = ?,\n approved_file_hash = ?\n WHERE id = ?\n `).run(body.user_id || 'api', fileHash, item.id);\n \n db.prepare(`\n INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n VALUES ('content_item', ?, 'approve', ?, datetime('now'))\n `).run(item.id, body.user_id || 'api');\n \n item = db.prepare('SELECT * FROM content_items WHERE id = ?').get(item.id);\n result = success(item, 'Item approved');\n }\n // POST /item/:id/reject\n else if (action === 'reject' && method === 'POST') {\n const reason = body.reason || 'Rejected by user';\n \n db.prepare(`\n UPDATE content_items\n SET status = 'REJECTED',\n error_message = ?\n WHERE id = ?\n `).run(reason, item.id);\n \n db.prepare(`\n INSERT INTO audit_log (entity_type, entity_id, action, new_value, user_id, created_at)\n VALUES ('content_item', ?, 'reject', ?, ?, datetime('now'))\n `).run(item.id, reason, body.user_id || 'api');\n \n item = db.prepare('SELECT * FROM content_items WHERE id = ?').get(item.id);\n result = success(item, 'Item rejected');\n }\n // POST /item/:id/caption\n else if (action === 'caption' && method === 'POST') {\n const captionIg = body.caption_ig !== undefined ? body.caption_ig : item.caption_ig;\n const captionTt = body.caption_tt !== undefined ? body.caption_tt : item.caption_tt;\n const hashtags = body.hashtags_final !== undefined ? body.hashtags_final : item.hashtags_final;\n \n db.prepare(`\n UPDATE content_items\n SET caption_ig = ?,\n caption_tt = ?,\n hashtags_final = ?\n WHERE id = ?\n `).run(captionIg, captionTt, hashtags, item.id);\n \n db.prepare(`\n INSERT INTO audit_log (entity_type, entity_id, action, field_changed, new_value, user_id, created_at)\n VALUES ('content_item', ?, 'update', 'caption', ?, ?, datetime('now'))\n `).run(item.id, (captionIg || '').substring(0, 200), body.user_id || 'api');\n \n item = db.prepare('SELECT * FROM content_items WHERE id = ?').get(item.id);\n result = success(item, 'Caption updated');\n }\n // POST /item/:id/regenerate - Queue for AI regeneration\n else if (action === 'regenerate' && method === 'POST') {\n db.prepare(`\n UPDATE content_items\n SET status = 'NEEDS_AI',\n caption_ig = NULL,\n caption_tt = NULL,\n error_message = NULL\n WHERE id = ?\n `).run(item.id);\n \n db.prepare(`\n INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n VALUES ('content_item', ?, 'regenerate', ?, datetime('now'))\n `).run(item.id, body.user_id || 'api');\n \n item = db.prepare('SELECT * FROM content_items WHERE id = ?').get(item.id);\n result = success(item, 'Item queued for caption regeneration. Run W2-Captions to process.');\n }\n // POST /item/:id/reschedule - Change schedule date/time\n else if (action === 'reschedule' && method === 'POST') {\n const { scheduled_date, scheduled_time, schedule_at } = body;\n \n if (!scheduled_date && !schedule_at) {\n result = error('scheduled_date or schedule_at required', 400);\n } else {\n const updates = [];\n const params = [];\n \n if (scheduled_date) { updates.push('scheduled_date = ?'); params.push(scheduled_date); }\n if (scheduled_time) { updates.push('scheduled_time = ?'); params.push(scheduled_time); }\n if (schedule_at) { updates.push('schedule_at = ?'); params.push(schedule_at); }\n \n // If item was already SCHEDULED, reset to APPROVED\n if (item.status === 'SCHEDULED') {\n updates.push(\"status = 'APPROVED'\");\n updates.push('late_post_id = NULL');\n }\n \n params.push(item.id);\n db.prepare(`UPDATE content_items SET ${updates.join(', ')} WHERE id = ?`).run(...params);\n \n db.prepare(`\n INSERT INTO audit_log (entity_type, entity_id, action, field_changed, new_value, user_id, created_at)\n VALUES ('content_item', ?, 'reschedule', 'schedule_at', ?, ?, datetime('now'))\n `).run(item.id, schedule_at || scheduled_date, body.user_id || 'api');\n \n item = db.prepare('SELECT * FROM content_items WHERE id = ?').get(item.id);\n result = success(item, 'Item rescheduled');\n }\n }\n else {\n result = error(`Unknown action: ${action}`, 400);\n }\n } finally {\n db.close();\n }\n }\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // APPROVE BATCH - Approve multiple items\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (base === 'approve-batch' && method === 'POST') {\n const ids = body.ids || [];\n \n if (!Array.isArray(ids) || ids.length === 0) {\n result = error('ids array required', 400);\n } else {\n const db = new Database(db_path);\n db.pragma('foreign_keys = ON');\n \n try {\n const updateStmt = db.prepare(`\n UPDATE content_items\n SET status = 'APPROVED',\n approved_at = datetime('now'),\n approved_by = ?,\n approved_file_hash = file_hash\n WHERE (id = ? OR content_id = ?) AND status IN ('NEEDS_REVIEW', 'NEEDS_AI')\n `);\n \n const auditStmt = db.prepare(`\n INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n SELECT 'content_item', id, 'approve', ?, datetime('now')\n FROM content_items WHERE id = ? OR content_id = ?\n `);\n \n let approved = 0;\n \n const approveMany = db.transaction((ids) => {\n for (const id of ids) {\n const info = updateStmt.run(body.user_id || 'api', id, id);\n if (info.changes > 0) {\n approved++;\n auditStmt.run(body.user_id || 'api', id, id);\n }\n }\n });\n \n approveMany(ids);\n \n result = success({ approved: approved, total: ids.length }, `Approved ${approved} items`);\n } finally {\n db.close();\n }\n }\n }\n \n\n // ============================================\n // ARCHIVE ENDPOINTS\n // ============================================\n\n // POST /clients/:slug/archive - Archive a client\n else if (method === 'POST' && parts.length === 3 && parts[2] === 'archive') {\n const slug = parts[1];\n const archivePath = db_path.replace('socialflow.db', 'socialflow_archive.db');\n \n if (!fs.existsSync(archivePath)) {\n result = error('Archive database not initialized. Run init_archive_database.js first.', 500);\n } else {\n const db = new Database(db_path);\n const archiveDb = new Database(archivePath);\n db.pragma('foreign_keys = ON');\n\n try {\n const client = db.prepare('SELECT * FROM clients WHERE slug = ?').get(slug);\n\n if (!client) {\n result = error(`Client not found: ${slug}`, 404);\n } else {\n // Insert into archive\n archiveDb.prepare(`\n INSERT INTO archived_clients (id, slug, name, language, timezone, type, brand_voice,\n brand_target_audience, brand_description, hashtags, platform_defaults, policy, original_created_at)\n VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n `).run(client.id, client.slug, client.name, client.language, client.timezone, client.type,\n client.brand_voice, client.brand_target_audience, client.brand_description,\n client.hashtags, client.platform_defaults, client.policy, client.created_at);\n\n // Archive accounts\n const accounts = db.prepare('SELECT * FROM accounts WHERE client_id = ?').all(client.id);\n for (const acc of accounts) {\n archiveDb.prepare(`\n INSERT INTO archived_accounts (id, archived_client_id, platform, late_account_id,\n username, display_name, profile_picture_url, original_created_at)\n VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n `).run(acc.id, client.id, acc.platform, acc.late_account_id,\n acc.username, acc.display_name, acc.profile_picture_url, acc.created_at);\n }\n\n // Archive batches\n const batches = db.prepare('SELECT * FROM batches WHERE client_id = ?').all(client.id);\n for (const batch of batches) {\n archiveDb.prepare(`\n INSERT INTO archived_batches (id, archived_client_id, slug, name, description,\n brief, hashtags, schedule_config, folder_path, status, original_created_at)\n VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n `).run(batch.id, client.id, batch.slug, batch.name, batch.description,\n batch.brief, batch.hashtags, batch.schedule_config, batch.folder_path, batch.status, batch.created_at);\n\n // Archive content items for this batch\n const items = db.prepare('SELECT * FROM content_items WHERE batch_id = ?').all(batch.id);\n for (const item of items) {\n archiveDb.prepare(`\n INSERT INTO archived_content_items (id, content_id, archived_client_id, archived_batch_id,\n media_type, file_name, file_path, file_hash, scheduled_date, scheduled_time,\n caption_ig, caption_tt, caption_override, hashtags_final, status, late_post_id, original_created_at)\n VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n `).run(item.id, item.content_id, client.id, batch.id,\n item.media_type, item.file_name, item.file_path, item.file_hash,\n item.scheduled_date, item.scheduled_time, item.caption_ig, item.caption_tt,\n item.caption_override, item.hashtags_final, item.status, item.late_post_id, item.created_at);\n }\n }\n\n // Delete from main database (cascades to accounts, batches, content_items)\n db.prepare('DELETE FROM clients WHERE id = ?').run(client.id);\n\n result = success({ slug, archived_at: new Date().toISOString() }, 'Client archived');\n }\n } finally {\n db.close();\n archiveDb.close();\n }\n }\n }\n\n // GET /archive/clients - List archived clients\n else if (base === 'archive' && parts.length === 2 && parts[1] === 'clients') {\n const archivePath = db_path.replace('socialflow.db', 'socialflow_archive.db');\n \n if (!fs.existsSync(archivePath)) {\n result = success([], 'No archived clients (archive database not initialized)');\n } else {\n const archiveDb = new Database(archivePath, { readonly: true });\n\n try {\n const clients = archiveDb.prepare(`\n SELECT ac.*,\n (SELECT COUNT(*) FROM archived_batches WHERE archived_client_id = ac.id) as batch_count,\n (SELECT COUNT(*) FROM archived_content_items WHERE archived_client_id = ac.id) as item_count\n FROM archived_clients ac\n ORDER BY ac.archived_at DESC\n `).all();\n\n result = success(clients, `Found ${clients.length} archived clients`);\n } finally {\n archiveDb.close();\n }\n }\n }\n\n // POST /archive/clients/:id/restore - Restore an archived client\n else if (method === 'POST' && base === 'archive' && parts.length === 4 && parts[3] === 'restore') {\n const archivedId = parseInt(parts[2]);\n const db = new Database(db_path);\n const archiveDb = new Database(db_path.replace('socialflow.db', 'socialflow_archive.db'));\n db.pragma('foreign_keys = ON');\n\n try {\n const archived = archiveDb.prepare('SELECT * FROM archived_clients WHERE id = ?').get(archivedId);\n\n if (!archived) {\n result = error(`Archived client not found: ${archivedId}`, 404);\n } else {\n // Check if slug already exists in main db\n const existing = db.prepare('SELECT id FROM clients WHERE slug = ?').get(archived.slug);\n if (existing) {\n result = error(`Client with slug '${archived.slug}' already exists. Delete it first or rename.`, 409);\n } else {\n // Restore client\n db.prepare(`\n INSERT INTO clients (id, slug, name, language, timezone, type, brand_voice,\n brand_target_audience, brand_description, hashtags, platform_defaults, policy,\n is_active, created_at, updated_at)\n VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 1, ?, datetime('now'))\n `).run(archived.id, archived.slug, archived.name, archived.language, archived.timezone,\n archived.type, archived.brand_voice, archived.brand_target_audience, archived.brand_description,\n archived.hashtags, archived.platform_defaults, archived.policy, archived.original_created_at);\n\n // Restore accounts\n const archivedAccounts = archiveDb.prepare('SELECT * FROM archived_accounts WHERE archived_client_id = ?').all(archivedId);\n for (const acc of archivedAccounts) {\n db.prepare(`\n INSERT INTO accounts (id, client_id, platform, late_account_id, username,\n display_name, profile_picture_url, is_active, created_at, updated_at)\n VALUES (?, ?, ?, ?, ?, ?, ?, 1, ?, datetime('now'))\n `).run(acc.id, archived.id, acc.platform, acc.late_account_id, acc.username,\n acc.display_name, acc.profile_picture_url, acc.original_created_at);\n }\n\n // Restore batches\n const archivedBatches = archiveDb.prepare('SELECT * FROM archived_batches WHERE archived_client_id = ?').all(archivedId);\n for (const batch of archivedBatches) {\n db.prepare(`\n INSERT INTO batches (id, client_id, slug, name, description, brief, hashtags,\n schedule_config, folder_path, status, created_at, updated_at)\n VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))\n `).run(batch.id, archived.id, batch.slug, batch.name, batch.description,\n batch.brief, batch.hashtags, batch.schedule_config, batch.folder_path,\n batch.status, batch.original_created_at);\n\n // Restore content items\n const archivedItems = archiveDb.prepare('SELECT * FROM archived_content_items WHERE archived_batch_id = ?').all(batch.id);\n for (const item of archivedItems) {\n db.prepare(`\n INSERT INTO content_items (id, content_id, client_id, batch_id, media_type,\n file_name, file_path, file_hash, scheduled_date, scheduled_time,\n caption_ig, caption_tt, caption_override, hashtags_final, status,\n late_post_id, created_at, updated_at)\n VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))\n `).run(item.id, item.content_id, archived.id, batch.id, item.media_type,\n item.file_name, item.file_path, item.file_hash, item.scheduled_date, item.scheduled_time,\n item.caption_ig, item.caption_tt, item.caption_override, item.hashtags_final,\n item.status, item.late_post_id, item.original_created_at);\n }\n }\n\n // Delete from archive\n archiveDb.prepare('DELETE FROM archived_clients WHERE id = ?').run(archivedId);\n\n result = success({ slug: archived.slug, restored_at: new Date().toISOString() }, 'Client restored');\n }\n }\n } finally {\n db.close();\n archiveDb.close();\n }\n }\n\n // DELETE /archive/clients/:id - Permanently delete archived client\n else if (method === 'DELETE' && base === 'archive' && parts.length === 3 && parts[1] === 'clients') {\n const archivedId = parseInt(parts[2]);\n const archiveDb = new Database(db_path.replace('socialflow.db', 'socialflow_archive.db'));\n\n try {\n const archived = archiveDb.prepare('SELECT slug FROM archived_clients WHERE id = ?').get(archivedId);\n\n if (!archived) {\n result = error(`Archived client not found: ${archivedId}`, 404);\n } else {\n archiveDb.prepare('DELETE FROM archived_clients WHERE id = ?').run(archivedId);\n result = success({ id: archivedId, slug: archived.slug }, 'Archived client permanently deleted');\n }\n } finally {\n archiveDb.close();\n }\n }\n\n\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // AGENTS - Agent settings and instruction management (Phase 3)\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (base === 'agents') {\n const agentsPath = `${config_base}/agents`;\n const settingsPath = `${config_base}/settings.json`;\n \n // GET /agents/settings - Get agent models and master prompts\n if (parts[1] === 'settings' && method === 'GET') {\n try {\n const settings = fs.existsSync(settingsPath) ? JSON.parse(fs.readFileSync(settingsPath, 'utf8')) : {};\n const agents = {};\n \n // Config Generator\n const configGenPath = `${agentsPath}/config_generator.md`;\n agents.config_generator = {\n model: settings.ollama?.models?.config_generator || settings.ollama?.model || 'llama3.2:3b',\n master_prompt: fs.existsSync(configGenPath) ? fs.readFileSync(configGenPath, 'utf8') : ''\n };\n \n // Caption Generator\n const captionGenPath = `${agentsPath}/caption_generator.md`;\n agents.caption_generator = {\n model: settings.ollama?.models?.caption_generator || settings.ollama?.model || 'llava:7b',\n master_prompt: fs.existsSync(captionGenPath) ? fs.readFileSync(captionGenPath, 'utf8') : ''\n };\n \n result = success(agents, 'Agent settings loaded');\n } catch (e) {\n result = error(`Failed to load agent settings: ${e.message}`, 500);\n }\n }\n // PUT /agents/settings - Update agent model or master prompt\n else if (parts[1] === 'settings' && method === 'PUT') {\n try {\n const { agent_type, model, master_prompt } = body;\n \n if (!agent_type || !['config_generator', 'caption_generator'].includes(agent_type)) {\n result = error('agent_type must be config_generator or caption_generator', 400);\n } else {\n // Update model in settings.json if provided\n if (model !== undefined) {\n const settings = fs.existsSync(settingsPath) ? JSON.parse(fs.readFileSync(settingsPath, 'utf8')) : {};\n if (!settings.ollama) settings.ollama = {};\n if (!settings.ollama.models) settings.ollama.models = {};\n settings.ollama.models[agent_type] = model;\n fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));\n }\n \n // Update master prompt file if provided\n if (master_prompt !== undefined) {\n if (!fs.existsSync(agentsPath)) fs.mkdirSync(agentsPath, { recursive: true });\n fs.writeFileSync(`${agentsPath}/${agent_type}.md`, master_prompt);\n }\n \n result = success({ agent_type, updated: { model: model !== undefined, master_prompt: master_prompt !== undefined } }, 'Agent settings updated');\n }\n } catch (e) {\n result = error(`Failed to update agent settings: ${e.message}`, 500);\n }\n }\n // GET /agents/instructions - Get system-level instructions\n else if (parts[1] === 'instructions' && method === 'GET') {\n const db = new Database(db_path, { readonly: true });\n try {\n const instructions = db.prepare(`\n SELECT * FROM agent_instructions\n WHERE scope = 'system' AND is_active = 1\n ORDER BY agent_type\n `).all();\n result = success(instructions, `Found ${instructions.length} system instructions`);\n } finally {\n db.close();\n }\n }\n // PUT /agents/instructions - Upsert system-level instruction\n else if (parts[1] === 'instructions' && method === 'PUT') {\n const db = new Database(db_path);\n db.pragma('foreign_keys = ON');\n \n try {\n const { agent_type, instruction_key, instruction_value } = body;\n \n if (!agent_type || !instruction_key) {\n result = error('agent_type and instruction_key are required', 400);\n } else {\n db.prepare(`\n INSERT INTO agent_instructions (agent_type, scope, scope_id, instruction_key, instruction_value, is_active, updated_at)\n VALUES (?, 'system', NULL, ?, ?, 1, datetime('now'))\n ON CONFLICT(agent_type, scope, scope_id, instruction_key)\n DO UPDATE SET instruction_value = excluded.instruction_value, updated_at = datetime('now')\n `).run(agent_type, instruction_key, instruction_value || '');\n \n result = success({ agent_type, instruction_key }, 'System instruction saved');\n }\n } finally {\n db.close();\n }\n }\n else {\n result = error(`Unknown agents route: ${route}`, 404);\n }\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // CLIENT INSTRUCTIONS - Client-level AI instructions\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (parts.length === 3 && parts[0] === 'clients' && parts[2] === 'instructions') {\n const clientSlug = parts[1];\n const db = new Database(db_path);\n db.pragma('foreign_keys = ON');\n \n try {\n const client = db.prepare('SELECT id FROM clients WHERE slug = ?').get(clientSlug);\n \n if (!client) {\n result = error(`Client not found: ${clientSlug}`, 404);\n }\n // GET /clients/:slug/instructions\n else if (method === 'GET') {\n const instructions = db.prepare(`\n SELECT * FROM agent_instructions\n WHERE scope = 'client' AND scope_id = ? AND is_active = 1\n ORDER BY agent_type\n `).all(client.id);\n result = success(instructions, `Found ${instructions.length} client instructions`);\n }\n // PUT /clients/:slug/instructions\n else if (method === 'PUT') {\n const { agent_type, instruction_key, instruction_value } = body;\n \n if (!agent_type || !instruction_key) {\n result = error('agent_type and instruction_key are required', 400);\n } else {\n db.prepare(`\n INSERT INTO agent_instructions (agent_type, scope, scope_id, instruction_key, instruction_value, is_active, updated_at)\n VALUES (?, 'client', ?, ?, ?, 1, datetime('now'))\n ON CONFLICT(agent_type, scope, scope_id, instruction_key)\n DO UPDATE SET instruction_value = excluded.instruction_value, updated_at = datetime('now')\n `).run(agent_type, client.id, instruction_key, instruction_value || '');\n \n result = success({ agent_type, instruction_key, client: clientSlug }, 'Client instruction saved');\n }\n }\n else {\n result = error('Method not allowed', 405);\n }\n } finally {\n db.close();\n }\n }\n \n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // BATCH SCHEDULE - Bulk update content item schedules\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // BATCH INSTRUCTIONS - Batch-level AI instructions\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else if (parts.length === 4 && parts[0] === 'batches' && parts[3] === 'instructions') {\n const clientSlug = parts[1];\n const batchSlug = parts[2];\n const db = new Database(db_path);\n db.pragma('foreign_keys = ON');\n \n try {\n const batch = db.prepare(`\n SELECT b.id FROM batches b\n JOIN clients c ON b.client_id = c.id\n WHERE c.slug = ? AND b.slug = ?\n `).get(clientSlug, batchSlug);\n \n if (!batch) {\n result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n }\n // GET /batches/:client/:batch/instructions\n else if (method === 'GET') {\n const instructions = db.prepare(`\n SELECT * FROM agent_instructions\n WHERE scope = 'batch' AND scope_id = ? AND is_active = 1\n ORDER BY agent_type\n `).all(batch.id);\n result = success(instructions, `Found ${instructions.length} batch instructions`);\n }\n // PUT /batches/:client/:batch/instructions\n else if (method === 'PUT') {\n const { agent_type, instruction_key, instruction_value } = body;\n \n if (!agent_type || !instruction_key) {\n result = error('agent_type and instruction_key are required', 400);\n } else {\n db.prepare(`\n INSERT INTO agent_instructions (agent_type, scope, scope_id, instruction_key, instruction_value, is_active, updated_at)\n VALUES (?, 'batch', ?, ?, ?, 1, datetime('now'))\n ON CONFLICT(agent_type, scope, scope_id, instruction_key)\n DO UPDATE SET instruction_value = excluded.instruction_value, updated_at = datetime('now')\n `).run(agent_type, batch.id, instruction_key, instruction_value || '');\n \n result = success({ agent_type, instruction_key, client: clientSlug, batch: batchSlug }, 'Batch instruction saved');\n }\n }\n else {\n result = error('Method not allowed', 405);\n }\n } finally {\n db.close();\n }\n }\n\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n // POST /clients/:slug/folder - Create client folder structure\n else if (base === 'clients' && parts.length === 3 && parts[2] === 'folder' && method === 'POST') {\n      const slug = parts[1];\n      const db = new Database(db_path);\n      db.pragma('foreign_keys = ON');\n\n      try {\n        const client = db.prepare('SELECT id, slug FROM clients WHERE slug = ?').get(slug);\n\n        if (!client) {\n          result = error(`Client not found: ${slug}`, 404);\n        } else {\n          const clientPath = `/data/clients/${slug}`;\n          const now = new Date();\n          const monthNames = ['january', 'february', 'march', 'april', 'may', 'june',\n                              'july', 'august', 'september', 'october', 'november', 'december'];\n          const monthName = monthNames[now.getMonth()];\n          const year = now.getFullYear();\n          const batchSlug = `${monthName}-${year}`;\n          const batchPath = `${clientPath}/${batchSlug}`;\n\n          // Create directory structure\n          const dirs = [\n            clientPath,\n            `${clientPath}/_config`,\n            batchPath,\n            `${batchPath}/photos`,\n            `${batchPath}/videos`\n          ];\n\n          for (const dir of dirs) {\n            if (!fs.existsSync(dir)) {\n              fs.mkdirSync(dir, { recursive: true });\n            }\n          }\n\n          // Create READY.txt for folder-based ingestion\n          fs.writeFileSync(`${batchPath}/READY.txt`, `Batch ready: ${new Date().toISOString()}\\n`);\n\n          // Create batch in database if not exists\n          const existingBatch = db.prepare('SELECT id FROM batches WHERE client_id = ? AND slug = ?').get(client.id, batchSlug);\n\n          let batchId;\n          if (!existingBatch) {\n            const displayName = monthName.charAt(0).toUpperCase() + monthName.slice(1) + ' ' + year;\n            const info = db.prepare(`\n              INSERT INTO batches (client_id, slug, name, description, source_type, status, created_at)\n              VALUES (?, ?, ?, ?, 'folder', 'draft', datetime('now'))\n            `).run(client.id, batchSlug, displayName, `Content batch for ${displayName}`);\n            batchId = info.lastInsertRowid;\n          } else {\n            batchId = existingBatch.id;\n          }\n\n          result = success({\n            client_slug: slug,\n            batch_slug: batchSlug,\n            batch_id: batchId,\n            batch_path: batchPath,\n            folders_created: dirs\n          }, `Created folder with batch: ${batchSlug}`);\n        }\n      } catch (err) {\n        result = error('Failed to create folder: ' + err.message, 500);\n      } finally {\n        db.close();\n      }\n    }\n\n // UNKNOWN ROUTE\n // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n else {\n result = error(`Unknown route: ${route}`, 404);\n }\n \n} catch (e) {\n console.log(`[API] Error: ${e.message}`);\n result = error(e.message, 500);\n}\n\nreturn [{ json: result }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        700
      ],
      "id": "api-handler",
      "name": "Route Handler"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Methods",
                "value": "GET, POST, PUT, DELETE, OPTIONS"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type, Authorization"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        960,
        700
      ],
      "id": "api-respond",
      "name": "Send Response"
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item => ({ json: { ...item.json, method: 'GET' } }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        500
      ],
      "id": "add-get-method",
      "name": "Add GET"
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item => ({ json: { ...item.json, method: 'POST' } }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        700
      ],
      "id": "add-post-method",
      "name": "Add POST"
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item => ({ json: { ...item.json, method: 'PUT' } }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        900
      ],
      "id": "add-put-method",
      "name": "Add PUT"
    },
    {
      "parameters": {
        "jsCode": "return $input.all().map(item => ({ json: { ...item.json, method: 'DELETE' } }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        1100
      ],
      "id": "add-delete-method",
      "name": "Add DELETE"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "w-upload",
        "responseMode": "responseNode",
        "options": {
          "binaryPropertyName": "file",
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        1200,
        500
      ],
      "id": "upload-webhook",
      "name": "Upload Webhook",
      "webhookId": "w-upload"
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst Database = require('better-sqlite3');\n\nconst { client_id, batch_id } = $input.first().json;\nconst binary = $input.first().binary?.file;\n\nif (!binary) {\n return [{ json: { success: false, error: 'No file provided', code: 400 } }];\n}\nif (!client_id) {\n return [{ json: { success: false, error: 'client_id required', code: 400 } }];\n}\n\n// Decode file first to check size\nconst buffer = Buffer.from(binary.data, 'base64');\nconst mimeType = binary.mimeType || 'application/octet-stream';\n\n// File validation\nconst MAX_FILE_SIZE = 500 * 1024 * 1024; // 500MB\nconst ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'video/mp4', 'video/quicktime', 'video/webm'];\n\nif (buffer.length > MAX_FILE_SIZE) {\n return [{ json: { success: false, error: 'File too large (max 500MB)', code: 400 } }];\n}\nif (!ALLOWED_TYPES.includes(mimeType)) {\n return [{ json: { success: false, error: `Invalid file type: ${mimeType}. Allowed: jpg, png, webp, gif, mp4, mov, webm`, code: 400 } }];\n}\n\n// Path sanitization to prevent traversal attacks\nconst sanitizePath = (s) => String(s).replace(/[^a-zA-Z0-9_-]/g, '');\nconst safeClientId = sanitizePath(client_id);\nconst safeBatchId = batch_id ? sanitizePath(batch_id) : 'pending';\n\n// Generate UUID and paths\nconst uuid = crypto.randomUUID();\nconst ext = path.extname(binary.fileName || '.bin').toLowerCase();\nconst storagePath = `/data/uploads/${safeClientId}/${safeBatchId}`;\nconst fullPath = `${storagePath}/${uuid}${ext}`;\n\n// Create directory and write file\nfs.mkdirSync(storagePath, { recursive: true });\nfs.writeFileSync(fullPath, buffer);\n\n// Compute file hash\nconst hash = crypto.createHash('md5').update(buffer).digest('hex');\nconst isVideo = mimeType.startsWith('video/');\n\n// Insert into database\nconst db = new Database('/data/clients/_config/socialflow.db');\ntry {\n const info = db.prepare(`\n INSERT INTO files (client_id, batch_id, original_name, storage_path, uuid,\n file_size, mime_type, checksum, status, uploaded_at)\n VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'ready', datetime('now'))\n `).run(client_id, batch_id || null, binary.fileName, fullPath, uuid,\n buffer.length, mimeType, hash);\n\n return [{\n json: {\n success: true,\n data: {\n file: {\n id: info.lastInsertRowid,\n uuid,\n storage_path: fullPath,\n status: 'ready'\n }\n }\n }\n }];\n} finally {\n db.close();\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        500
      ],
      "id": "upload-handler",
      "name": "Upload Handler"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        1600,
        500
      ],
      "id": "upload-respond",
      "name": "Upload Response"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "w-onboarding-complete",
        "responseMode": "responseNode",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        1200,
        700
      ],
      "id": "onboarding-webhook",
      "name": "Onboarding Complete Webhook",
      "webhookId": "w-onboarding-complete"
    },
    {
      "parameters": {
        "jsCode": "const Database = require('better-sqlite3');\nconst input = $input.first().json;\nconst { client_id, batch_id, start_date, schedule_strategy } = input;\n\nconst db = new Database('/data/clients/_config/socialflow.db');\n\ntry {\n // Get client and batch info\n const client = db.prepare('SELECT * FROM clients WHERE id = ?').get(client_id);\n const batch = db.prepare('SELECT * FROM batches WHERE id = ?').get(batch_id);\n\n if (!client || !batch) {\n return [{ json: { success: false, error: 'Client or batch not found', code: 404 } }];\n }\n\n const files = db.prepare(`\n SELECT * FROM files WHERE batch_id = ? AND status = 'ready' ORDER BY uploaded_at\n `).all(batch_id);\n\n if (!files.length) {\n return [{ json: { success: false, error: 'No ready files found', code: 400 } }];\n }\n\n // Get existing content_ids to prevent duplicates\n const existingIds = new Set(\n db.prepare('SELECT content_id FROM content_items WHERE batch_id = ?')\n .all(batch_id).map(r => r.content_id)\n );\n\n // Generate schedule dates\n const startDate = new Date(start_date || new Date().toISOString().split('T')[0]);\n const daysToAdd = schedule_strategy === 'weekly' ? 7 : 1;\n let currentDate = new Date(startDate);\n let created = 0;\n let skipped = 0;\n const timezone = client.timezone || 'Europe/Berlin';\n const scheduledTime = '20:00:00';\n\n const insertItem = db.prepare(`\n INSERT INTO content_items (\n content_id, client_id, batch_id, media_type, file_name, file_path,\n file_size, file_hash, scheduled_date, scheduled_time, schedule_at, timezone,\n slot, platforms, status, file_id, created_at\n ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'feed', 'ig', 'NEEDS_AI', ?, datetime('now'))\n `);\n\n const updateFile = db.prepare('UPDATE files SET content_item_id = ? WHERE id = ?');\n\n const insertMany = db.transaction(() => {\n for (let i = 0; i < files.length; i++) {\n const file = files[i];\n const dateStr = currentDate.toISOString().split('T')[0];\n const scheduleAt = `${dateStr}T${scheduledTime}`;\n const mediaType = file.mime_type?.startsWith('video') ? 'video' : 'photo';\n const contentId = `${client.slug}__${batch.slug}__${dateStr}__feed__${mediaType}__${String(i+1).padStart(2,'0')}`;\n\n // Skip if content_id already exists\n if (existingIds.has(contentId)) {\n skipped++;\n currentDate.setDate(currentDate.getDate() + daysToAdd);\n continue;\n }\n\n const info = insertItem.run(\n contentId, client_id, batch_id, mediaType, file.original_name,\n file.storage_path, file.file_size, file.checksum, dateStr, scheduledTime,\n scheduleAt, timezone, file.id\n );\n updateFile.run(info.lastInsertRowid, file.id);\n\n currentDate.setDate(currentDate.getDate() + daysToAdd);\n created++;\n }\n });\n\n insertMany();\n\n // Update batch status\n db.prepare(`UPDATE batches SET status = 'ready' WHERE id = ?`).run(batch_id);\n\n return [{\n json: {\n success: true,\n data: {\n client_slug: client.slug,\n batch_slug: batch.slug,\n file_count: files.length,\n content_items_created: created,\n skipped_duplicates: skipped\n }\n }\n }];\n} finally {\n db.close();\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        700
      ],
      "id": "onboarding-handler",
      "name": "Onboarding Complete Handler"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        1600,
        700
      ],
      "id": "onboarding-respond",
      "name": "Onboarding Complete Response"
    }
  ],
  "connections": {
    "GET Webhook": {
      "main": [
        [
          {
            "node": "Add GET",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "POST Webhook": {
      "main": [
        [
          {
            "node": "Add POST",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PUT Webhook": {
      "main": [
        [
          {
            "node": "Add PUT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DELETE Webhook": {
      "main": [
        [
          {
            "node": "Add DELETE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Requests": {
      "main": [
        [
          {
            "node": "Route Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Parser": {
      "main": [
        [
          {
            "node": "Route Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Handler": {
      "main": [
        [
          {
            "node": "Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add GET": {
      "main": [
        [
          {
            "node": "Merge Requests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add POST": {
      "main": [
        [
          {
            "node": "Merge Requests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add PUT": {
      "main": [
        [
          {
            "node": "Merge Requests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add DELETE": {
      "main": [
        [
          {
            "node": "Merge Requests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Webhook": {
      "main": [
        [
          {
            "node": "Upload Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Handler": {
      "main": [
        [
          {
            "node": "Upload Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Onboarding Complete Webhook": {
      "main": [
        [
          {
            "node": "Onboarding Complete Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Onboarding Complete Handler": {
      "main": [
        [
          {
            "node": "Onboarding Complete Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "pinData": {},
  "active": true,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "tags": [],
  "versionId": "cf12cc19-3340-408a-948d-e22decee9903"
}
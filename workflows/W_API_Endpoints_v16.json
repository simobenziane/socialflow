{
    "name":  "W-API: Endpoints v16",
    "nodes":  [
                  {
                      "parameters":  {
                                         "httpMethod":  "=GET",
                                         "path":  "api",
                                         "responseMode":  "responseNode",
                                         "options":  {
                                                         "responseHeaders":  {
                                                                                 "entries":  [
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Origin",
                                                                                                     "value":  "*"
                                                                                                 },
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Methods",
                                                                                                     "value":  "GET, POST, PUT, DELETE, OPTIONS"
                                                                                                 },
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Headers",
                                                                                                     "value":  "Content-Type, Authorization"
                                                                                                 }
                                                                                             ]
                                                                             }
                                                     }
                                     },
                      "type":  "n8n-nodes-base.webhook",
                      "typeVersion":  2.1,
                      "position":  [
                                       0,
                                       500
                                   ],
                      "id":  "api-webhook-get",
                      "name":  "GET Webhook",
                      "webhookId":  "api-webhook"
                  },
                  {
                      "parameters":  {
                                         "httpMethod":  "POST",
                                         "path":  "api",
                                         "responseMode":  "responseNode",
                                         "options":  {
                                                         "responseHeaders":  {
                                                                                 "entries":  [
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Origin",
                                                                                                     "value":  "*"
                                                                                                 },
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Methods",
                                                                                                     "value":  "GET, POST, PUT, DELETE, OPTIONS"
                                                                                                 },
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Headers",
                                                                                                     "value":  "Content-Type, Authorization"
                                                                                                 }
                                                                                             ]
                                                                             }
                                                     }
                                     },
                      "type":  "n8n-nodes-base.webhook",
                      "typeVersion":  2.1,
                      "position":  [
                                       0,
                                       700
                                   ],
                      "id":  "api-webhook-post",
                      "name":  "POST Webhook",
                      "webhookId":  "api-webhook-post"
                  },
                  {
                      "parameters":  {
                                         "httpMethod":  "PUT",
                                         "path":  "api",
                                         "responseMode":  "responseNode",
                                         "options":  {
                                                         "responseHeaders":  {
                                                                                 "entries":  [
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Origin",
                                                                                                     "value":  "*"
                                                                                                 },
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Methods",
                                                                                                     "value":  "GET, POST, PUT, DELETE, OPTIONS"
                                                                                                 },
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Headers",
                                                                                                     "value":  "Content-Type, Authorization"
                                                                                                 }
                                                                                             ]
                                                                             }
                                                     }
                                     },
                      "type":  "n8n-nodes-base.webhook",
                      "typeVersion":  2.1,
                      "position":  [
                                       0,
                                       900
                                   ],
                      "id":  "api-webhook-put",
                      "name":  "PUT Webhook",
                      "webhookId":  "api-webhook-put"
                  },
                  {
                      "parameters":  {
                                         "httpMethod":  "DELETE",
                                         "path":  "api",
                                         "responseMode":  "responseNode",
                                         "options":  {
                                                         "responseHeaders":  {
                                                                                 "entries":  [
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Origin",
                                                                                                     "value":  "*"
                                                                                                 },
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Methods",
                                                                                                     "value":  "GET, POST, PUT, DELETE, OPTIONS"
                                                                                                 },
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Headers",
                                                                                                     "value":  "Content-Type, Authorization"
                                                                                                 }
                                                                                             ]
                                                                             }
                                                     }
                                     },
                      "type":  "n8n-nodes-base.webhook",
                      "typeVersion":  2.1,
                      "position":  [
                                       0,
                                       1100
                                   ],
                      "id":  "api-webhook-delete",
                      "name":  "DELETE Webhook",
                      "webhookId":  "api-webhook-delete"
                  },
                  {
                      "parameters":  {
                                         "mode":  "runOnceForAllItems",
                                         "jsCode":  "const items = $input.all();\nconst merged = [];\nfor (const item of items) {\n  merged.push(item);\n}\nreturn merged;"
                                     },
                      "type":  "n8n-nodes-base.code",
                      "typeVersion":  2,
                      "position":  [
                                       240,
                                       700
                                   ],
                      "id":  "api-merge",
                      "name":  "Merge Requests"
                  },
                  {
                      "parameters":  {
                                         "mode":  "runOnceForAllItems",
                                         "jsCode":  "// W-API v16: Route Parser\nconst input = $input.first().json;\nconst method = input.method || \u0027GET\u0027;\nconst query = input.query || {};\nconst body = input.body || {};\n\nconst route = query.route || body.route || \u0027/health\u0027;\n\nconst CONFIG_BASE = \u0027/data/clients/_config\u0027;\nconst DB_PATH = `${CONFIG_BASE}/socialflow.db`;\n\nconsole.log(`[API] ${method} ${route}`);\n\nreturn [{\n  json: {\n    route: route,\n    method: method,\n    query: query,\n    body: body,\n    db_path: DB_PATH,\n    config_base: CONFIG_BASE\n  }\n}];"
                                     },
                      "type":  "n8n-nodes-base.code",
                      "typeVersion":  2,
                      "position":  [
                                       480,
                                       700
                                   ],
                      "id":  "api-router",
                      "name":  "Route Parser"
                  },
                  {
                      "parameters":  {
                                         "mode":  "runOnceForAllItems",
                                         "jsCode":  "// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n// â•‘  W-API v16: ROUTE HANDLER - Enhanced with Agent Instructions   â•‘\n// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst Database = require(\u0027better-sqlite3\u0027);\nconst fs = require(\u0027fs\u0027);\nconst crypto = require(\u0027crypto\u0027);\n\nconst input = $input.first().json;\nconst { route, method, query, body, db_path, config_base } = input;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// HELPER FUNCTIONS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nfunction success(data, message = \u0027OK\u0027) {\n  return { success: true, message, data, timestamp: new Date().toISOString() };\n}\n\nfunction error(message, code = 400) {\n  return { success: false, error: message, code, timestamp: new Date().toISOString() };\n}\n\nfunction parseRoute(route) {\n  // Handle query params in route\n  const routePath = route.split(\u0027?\u0027)[0];\n  const parts = routePath.split(\u0027/\u0027).filter(p =\u003e p);\n  return { parts, base: parts[0] || \u0027health\u0027 };\n}\n\n// Status constants for type safety\nconst STATUS = {\n  PENDING: \u0027PENDING\u0027,\n  NEEDS_AI: \u0027NEEDS_AI\u0027,\n  NEEDS_REVIEW: \u0027NEEDS_REVIEW\u0027,\n  APPROVED: \u0027APPROVED\u0027,\n  SCHEDULED: \u0027SCHEDULED\u0027,\n  FAILED: \u0027FAILED\u0027,\n  DELETED: \u0027DELETED\u0027,\n  REJECTED: \u0027REJECTED\u0027,\n  BLOCKED: \u0027BLOCKED\u0027\n};\n\n// Valid content item statuses (whitelist for SQL injection prevention)\nconst VALID_STATUSES = Object.values(STATUS);\n\n// Parse JSON fields from client record\nfunction parseClientJSON(client) {\n  if (!client) return client;\n  return {\n    ...client,\n    hashtags: JSON.parse(client.hashtags || \u0027[]\u0027),\n    platform_defaults: JSON.parse(client.platform_defaults || \u0027{}\u0027),\n    policy: JSON.parse(client.policy || \u0027{}\u0027)\n  };\n}\n\n// Parse JSON fields from batch record\nfunction parseBatchJSON(batch) {\n  if (!batch) return batch;\n  return {\n    ...batch,\n    hashtags: JSON.parse(batch.hashtags || \u0027[]\u0027),\n    schedule_config: JSON.parse(batch.schedule_config || \u0027{}\u0027)\n  };\n}\n\n// Validate schedule item format\nfunction validateScheduleItem(item) {\n  if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(item.scheduled_date)) {\n    throw new Error(`Invalid date format for item ${item.id}: expected YYYY-MM-DD`);\n  }\n  if (!/^\\d{2}:\\d{2}(:\\d{2})?$/.test(item.scheduled_time)) {\n    throw new Error(`Invalid time format for item ${item.id}: expected HH:MM or HH:MM:SS`);\n  }\n  if (item.slot \u0026\u0026 ![\u0027feed\u0027, \u0027story\u0027].includes(item.slot)) {\n    throw new Error(`Invalid slot for item ${item.id}: must be feed or story`);\n  }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// CHECK DATABASE (skip for some routes)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst skipDbRoutes = [\u0027health\u0027, \u0027settings\u0027, \u0027late\u0027, \u0027jobs\u0027];\nconst { parts, base } = parseRoute(route);\n\nif (!fs.existsSync(db_path) \u0026\u0026 !skipDbRoutes.includes(base)) {\n  return [{ json: error(\u0027Database not found. Run init_database.js first.\u0027, 500) }];\n}\n\nlet result = {};\n\ntry {\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // HEALTH CHECK\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  if (route === \u0027/health\u0027 || base === \u0027health\u0027) {\n    result = success({\n      status: \u0027healthy\u0027,\n      version: \u0027v16\u0027,\n      database: fs.existsSync(db_path) ? \u0027connected\u0027 : \u0027not_found\u0027,\n      storage: \u0027SQLite\u0027\n    }, \u0027API is healthy\u0027);\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // SETTINGS - Get/Update application settings\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (base === \u0027settings\u0027) {\n    const settingsPath = `${config_base}/settings.json`;\n    \n    if (!fs.existsSync(settingsPath)) {\n      result = error(\u0027Settings file not found\u0027, 500);\n    }\n    // POST /settings/test-cloudflare - Test Cloudflare tunnel connectivity\n    else if (parts[1] === \u0027test-cloudflare\u0027 \u0026\u0026 method === \u0027POST\u0027) {\n      try {\n        const settings = JSON.parse(fs.readFileSync(settingsPath, \u0027utf8\u0027));\n        const cfUrl = settings.cloudflare_tunnel_url;\n        \n        if (!cfUrl || !cfUrl.startsWith(\u0027https://\u0027)) {\n          result = { success: false, message: \u0027No valid Cloudflare URL configured\u0027, url: cfUrl };\n        } else {\n          // Return a special flag to trigger HTTP test in a separate workflow path\n          // The actual test will be done via n8n\u0027s HTTP Request node\n          result = { \n            _test_cloudflare: true, \n            test_url: `${cfUrl}/_config/settings.json?_t=${Date.now()}`,\n            cloudflare_url: cfUrl \n          };\n        }\n      } catch (err) {\n        result = error(`Test failed: ${err.message}`, 500);\n      }\n    }\n    else if (method === \u0027PUT\u0027 || method === \u0027POST\u0027) {\n      // Update settings\n      const current = JSON.parse(fs.readFileSync(settingsPath, \u0027utf8\u0027));\n      const updates = body || {};\n      \n      // Shallow merge with nested object support\n      const merged = { ...current };\n      \n      // Handle top-level fields\n      if (updates.cloudflare_tunnel_url !== undefined) {\n        merged.cloudflare_tunnel_url = updates.cloudflare_tunnel_url;\n      }\n      \n      // Handle nested objects\n      if (updates.paths) {\n        merged.paths = { ...current.paths, ...updates.paths };\n      }\n      if (updates.ollama) {\n        merged.ollama = { ...current.ollama, ...updates.ollama };\n      }\n      if (updates.ai_provider !== undefined) {\n        merged.ai_provider = updates.ai_provider;\n      }\n      if (updates.gemini) {\n        merged.gemini = { ...current.gemini, ...updates.gemini };\n      }\n      if (updates.defaults) {\n        merged.defaults = { ...current.defaults, ...updates.defaults };\n      }\n      if (updates.late_api) {\n        merged.late_api = { ...current.late_api, ...updates.late_api };\n      }\n      if (updates.database) {\n        merged.database = { ...current.database, ...updates.database };\n      }\n      \n      // Write back (atomic: write to .tmp then rename)\n      const settingsTmp = `${settingsPath}.tmp`;\n      fs.writeFileSync(settingsTmp, JSON.stringify(merged, null, 2));\n      fs.renameSync(settingsTmp, settingsPath);\n      \n      // Return without deprecated fields\n      const response = { ...merged };\n      delete response.google_sheets;\n      \n      result = success(response, \u0027Settings updated\u0027);\n    }\n    else {\n      // GET settings\n      const settings = JSON.parse(fs.readFileSync(settingsPath, \u0027utf8\u0027));\n      \n      // Remove deprecated fields for UI\n      delete settings.google_sheets;\n      \n      result = success(settings, \u0027Settings loaded\u0027);\n    }\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // LATE - Late.com account cache and sync\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (base === \u0027late\u0027) {\n    if (parts[1] === \u0027accounts\u0027) {\n      const cachePath = `${config_base}/late_accounts.json`;\n      \n      if (!fs.existsSync(cachePath)) {\n        result = success({ accounts: [], profiles: [], synced_at: null }, \u0027No cached accounts - run sync first\u0027);\n      } else {\n        const data = JSON.parse(fs.readFileSync(cachePath, \u0027utf8\u0027));\n        result = success(data, \u0027Cached accounts loaded\u0027);\n      }\n    }\n    else if (parts[1] === \u0027sync\u0027 \u0026\u0026 method === \u0027POST\u0027) {\n      // Return instruction to call W0 webhook\n      result = success({ action: \u0027trigger_w0_sync\u0027, webhook: \u0027/w0-sync\u0027 }, \u0027Trigger W0 sync via webhook /w0-sync\u0027);\n    }\n    else {\n      result = error(`Unknown late route: ${route}`, 404);\n    }\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // JOBS - Job tracking status for UI retry support\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (base === \u0027jobs\u0027) {\n    const jobPath = `${config_base}/active_job.json`;\n    \n    if (!fs.existsSync(jobPath)) {\n      result = success({\n        current: { client: null, batch: null },\n        executions: { W0: null, W1: null, W2: null, W3: null }\n      }, \u0027No job tracking data - run a workflow first\u0027);\n    } else {\n      try {\n        const jobs = JSON.parse(fs.readFileSync(jobPath, \u0027utf8\u0027));\n        \n        // Ensure structure exists\n        if (!jobs.current) jobs.current = { client: null, batch: null };\n        if (!jobs.executions) jobs.executions = { W0: null, W1: null, W2: null, W3: null };\n        \n        result = success(jobs, \u0027Job tracking status\u0027);\n      } catch (e) {\n        result = error(`Failed to read job status: ${e.message}`, 500);\n      }\n    }\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // STATS - Dashboard statistics\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (base === \u0027stats\u0027) {\n    const db = new Database(db_path, { readonly: true });\n    try {\n      // Consolidated stats queries (7 queries â†’ 2 queries)\n      const entityCounts = db.prepare(`\n        SELECT\n          (SELECT COUNT(*) FROM clients WHERE is_active = 1) as clients,\n          (SELECT COUNT(*) FROM batches) as batches,\n          (SELECT COUNT(*) FROM accounts WHERE is_active = 1) as accounts\n      `).get();\n      \n      const contentStats = db.prepare(`\n        SELECT\n          COUNT(*) as total,\n          SUM(CASE WHEN status = \u0027PENDING\u0027 THEN 1 ELSE 0 END) as pending,\n          SUM(CASE WHEN status = \u0027NEEDS_AI\u0027 THEN 1 ELSE 0 END) as needs_ai,\n          SUM(CASE WHEN status = \u0027NEEDS_REVIEW\u0027 THEN 1 ELSE 0 END) as needs_review,\n          SUM(CASE WHEN status = \u0027APPROVED\u0027 THEN 1 ELSE 0 END) as approved,\n          SUM(CASE WHEN status = \u0027SCHEDULED\u0027 THEN 1 ELSE 0 END) as scheduled,\n          SUM(CASE WHEN status = \u0027FAILED\u0027 THEN 1 ELSE 0 END) as failed\n        FROM content_items\n      `).get();\n      \n      const stats = {\n        clients: entityCounts.clients,\n        batches: entityCounts.batches,\n        content_items: {\n          total: contentStats.total || 0,\n          pending: contentStats.pending || 0,\n          needs_ai: contentStats.needs_ai || 0,\n          needs_review: contentStats.needs_review || 0,\n          approved: contentStats.approved || 0,\n          scheduled: contentStats.scheduled || 0,\n          failed: contentStats.failed || 0\n        },\n        accounts: entityCounts.accounts\n      };\n      result = success(stats, \u0027Dashboard statistics\u0027);\n    } finally {\n      db.close();\n    }\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // CLIENTS - CRUD operations\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (base === \u0027clients\u0027) {\n    // POST /clients - Create new client\n    if (method === \u0027POST\u0027 \u0026\u0026 parts.length === 1) {\n      const { name, slug, type, language, timezone, instagram_account_id, tiktok_account_id } = body;\n      \n      if (!name || !slug) {\n        result = error(\u0027name and slug are required\u0027, 400);\n      } else {\n        const db = new Database(db_path);\n        db.pragma(\u0027foreign_keys = ON\u0027);\n        \n        try {\n          // Check if exists\n          const existing = db.prepare(\u0027SELECT id FROM clients WHERE slug = ?\u0027).get(slug);\n          \n          if (existing) {\n            result = error(`Client already exists: ${slug}`, 409);\n          } else {\n            const info = db.prepare(`\n              INSERT INTO clients (slug, name, type, language, timezone, is_active, created_at)\n              VALUES (?, ?, ?, ?, ?, 1, datetime(\u0027now\u0027))\n            `).run(slug, name, type || \u0027business\u0027, language || \u0027en\u0027, timezone || \u0027Europe/Berlin\u0027);\n            \n            // Add accounts if provided\n            if (instagram_account_id) {\n              db.prepare(`\n                INSERT INTO accounts (client_id, platform, late_account_id, is_default, is_active, created_at)\n                VALUES (?, \u0027instagram\u0027, ?, 1, 1, datetime(\u0027now\u0027))\n              `).run(info.lastInsertRowid, instagram_account_id);\n            }\n            if (tiktok_account_id) {\n              db.prepare(`\n                INSERT INTO accounts (client_id, platform, late_account_id, is_default, is_active, created_at)\n                VALUES (?, \u0027tiktok\u0027, ?, 1, 1, datetime(\u0027now\u0027))\n              `).run(info.lastInsertRowid, tiktok_account_id);\n            }\n            \n            // Log audit\n            db.prepare(`\n              INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n              VALUES (\u0027client\u0027, ?, \u0027create\u0027, ?, datetime(\u0027now\u0027))\n            `).run(info.lastInsertRowid, body.user_id || \u0027api\u0027);\n            \n            const client = db.prepare(\u0027SELECT * FROM clients WHERE id = ?\u0027).get(info.lastInsertRowid);\n            client.hashtags = JSON.parse(client.hashtags || \u0027[]\u0027);\n            client.platform_defaults = JSON.parse(client.platform_defaults || \u0027{}\u0027);\n            client.policy = JSON.parse(client.policy || \u0027{}\u0027);\n\n            // Build accounts object from what we just inserted\n            client.accounts = {};\n            if (instagram_account_id) {\n              client.accounts.instagram = { late_account_id: instagram_account_id, username: \u0027\u0027 };\n            }\n            if (tiktok_account_id) {\n              client.accounts.tiktok = { late_account_id: tiktok_account_id, username: \u0027\u0027 };\n            }\n\n            result = success(client, \u0027Client created\u0027);\n          }\n        } finally {\n          db.close();\n        }\n      }\n    }\n    // PUT /clients/:slug - Update client\n    else if (method === \u0027PUT\u0027 \u0026\u0026 parts.length === 2) {\n      const slug = parts[1];\n      const db = new Database(db_path);\n      db.pragma(\u0027foreign_keys = ON\u0027);\n      \n      try {\n        const client = db.prepare(\u0027SELECT * FROM clients WHERE slug = ?\u0027).get(slug);\n        \n        if (!client) {\n          result = error(`Client not found: ${slug}`, 404);\n        } else {\n          const updates = [];\n          const params = [];\n          \n          if (body.name !== undefined) { updates.push(\u0027name = ?\u0027); params.push(body.name); }\n          if (body.type !== undefined) { updates.push(\u0027type = ?\u0027); params.push(body.type); }\n          if (body.language !== undefined) { updates.push(\u0027language = ?\u0027); params.push(body.language); }\n          if (body.timezone !== undefined) { updates.push(\u0027timezone = ?\u0027); params.push(body.timezone); }\n          if (body.is_active !== undefined) { updates.push(\u0027is_active = ?\u0027); params.push(body.is_active ? 1 : 0); }\n          if (body.hashtags !== undefined) { updates.push(\u0027hashtags = ?\u0027); params.push(JSON.stringify(body.hashtags)); }\n          if (body.platform_defaults !== undefined) { updates.push(\u0027platform_defaults = ?\u0027); params.push(JSON.stringify(body.platform_defaults)); }\n          if (body.policy !== undefined) { updates.push(\u0027policy = ?\u0027); params.push(JSON.stringify(body.policy)); }\n          \n          if (updates.length \u003e 0) {\n            params.push(client.id);\n            db.prepare(`UPDATE clients SET ${updates.join(\u0027, \u0027)} WHERE id = ?`).run(...params);\n            \n            // Log audit\n            db.prepare(`\n              INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n              VALUES (\u0027client\u0027, ?, \u0027update\u0027, ?, datetime(\u0027now\u0027))\n            `).run(client.id, body.user_id || \u0027api\u0027);\n          }\n          \n          const updated = db.prepare(\u0027SELECT * FROM clients WHERE id = ?\u0027).get(client.id);\n          updated.hashtags = JSON.parse(updated.hashtags || \u0027[]\u0027);\n          updated.platform_defaults = JSON.parse(updated.platform_defaults || \u0027{}\u0027);\n          updated.policy = JSON.parse(updated.policy || \u0027{}\u0027);\n          \n          result = success(updated, \u0027Client updated\u0027);\n        }\n      } finally {\n        db.close();\n      }\n    }\n    // DELETE /clients/:slug - Hard delete client with full cascade\n    else if (method === \u0027DELETE\u0027 \u0026\u0026 parts.length === 2) {\n      const slug = parts[1];\n      const db = new Database(db_path);\n      db.pragma(\u0027foreign_keys = ON\u0027);\n      \n      try {\n        const client = db.prepare(\u0027SELECT * FROM clients WHERE slug = ?\u0027).get(slug);\n        \n        if (!client) {\n          result = error(`Client not found: ${slug}`, 404);\n        } else {\n          // Use transaction for proper cascade delete\n          const deleteClient = db.transaction(() =\u003e {\n            // Delete in order: files -\u003e content_items -\u003e batches -\u003e accounts -\u003e client\n            db.prepare(\u0027DELETE FROM files WHERE client_id = ?\u0027).run(client.id);\n            db.prepare(\u0027DELETE FROM content_items WHERE client_id = ?\u0027).run(client.id);\n            db.prepare(\u0027DELETE FROM batches WHERE client_id = ?\u0027).run(client.id);\n            db.prepare(\u0027DELETE FROM accounts WHERE client_id = ?\u0027).run(client.id);\n            db.prepare(\u0027DELETE FROM clients WHERE id = ?\u0027).run(client.id);\n          });\n          deleteClient();\n          \n          result = success({ slug }, \u0027Client deleted\u0027);\n        }\n      } finally {\n        db.close();\n      }\n    }\n    // GET /clients - List all clients with accounts (optimized: 2 queries instead of N+1)\n    else if (parts.length === 1) {\n      const db = new Database(db_path, { readonly: true });\n      try {\n        const clients = db.prepare(`\n          SELECT c.*,\n            (SELECT COUNT(*) FROM batches WHERE client_id = c.id) as batch_count,\n            (SELECT COUNT(*) FROM accounts WHERE client_id = c.id AND is_active = 1) as account_count,\n            (SELECT COUNT(*) FROM content_items ci JOIN batches b ON ci.batch_id = b.id WHERE b.client_id = c.id) as item_count\n          FROM clients c\n          WHERE c.is_active = 1\n          ORDER BY c.name\n        `).all();\n\n        // Fetch ALL accounts in one query, then build a map (eliminates N+1)\n        const allAccounts = db.prepare(`\n          SELECT client_id, platform, late_account_id, username\n          FROM accounts WHERE is_active = 1\n        `).all();\n        \n        const accountMap = {};\n        for (const acc of allAccounts) {\n          if (!accountMap[acc.client_id]) accountMap[acc.client_id] = {};\n          accountMap[acc.client_id][acc.platform] = {\n            late_account_id: acc.late_account_id,\n            username: acc.username || \u0027\u0027\n          };\n        }\n\n        // Parse JSON fields and attach pre-fetched accounts\n        for (const client of clients) {\n          client.hashtags = JSON.parse(client.hashtags || \u0027[]\u0027);\n          client.platform_defaults = JSON.parse(client.platform_defaults || \u0027{}\u0027);\n          client.policy = JSON.parse(client.policy || \u0027{}\u0027);\n          client.accounts = accountMap[client.id] || {};\n        }\n\n        result = success(clients, `Found ${clients.length} clients`);\n      } finally {\n        db.close();\n      }\n    }\n    // GET /clients/:slug - Get single client with accounts\n    else if (parts.length === 2) {\n      const db = new Database(db_path, { readonly: true });\n      try {\n        const slug = parts[1];\n        const client = db.prepare(\u0027SELECT * FROM clients WHERE slug = ?\u0027).get(slug);\n\n        if (!client) {\n          result = error(`Client not found: ${slug}`, 404);\n        } else {\n          client.hashtags = JSON.parse(client.hashtags || \u0027[]\u0027);\n          client.platform_defaults = JSON.parse(client.platform_defaults || \u0027{}\u0027);\n          client.policy = JSON.parse(client.policy || \u0027{}\u0027);\n\n          // Fetch linked accounts and build accounts object\n          const accounts = db.prepare(\u0027SELECT * FROM accounts WHERE client_id = ? AND is_active = 1\u0027).all(client.id);\n          client.accounts = {};\n          for (const acc of accounts) {\n            client.accounts[acc.platform] = {\n              late_account_id: acc.late_account_id,\n              username: acc.username || \u0027\u0027\n            };\n          }\n\n          result = success(client);\n        }\n      } finally {\n        db.close();\n      }\n    }\n    // GET /clients/:slug/accounts\n    else if (parts.length === 3 \u0026\u0026 parts[2] === \u0027accounts\u0027) {\n      const db = new Database(db_path, { readonly: true });\n      try {\n        const slug = parts[1];\n        const client = db.prepare(\u0027SELECT id FROM clients WHERE slug = ?\u0027).get(slug);\n        \n        if (!client) {\n          result = error(`Client not found: ${slug}`, 404);\n        } else {\n          const accounts = db.prepare(`\n            SELECT * FROM accounts WHERE client_id = ? ORDER BY platform, is_default DESC\n          `).all(client.id);\n          result = success(accounts, `Found ${accounts.length} accounts`);\n        }\n      } finally {\n        db.close();\n      }\n    }\n    // GET /clients/:slug/batches - Hybrid filesystem + database\n    else if (parts.length === 3 \u0026\u0026 parts[2] === \u0027batches\u0027) {\n      const db = new Database(db_path, { readonly: true });\n      try {\n        const slug = parts[1];\n        const client = db.prepare(\u0027SELECT id FROM clients WHERE slug = ?\u0027).get(slug);\n        \n        if (!client) {\n          result = error(`Client not found: ${slug}`, 404);\n        } else {\n          // 1. Scan filesystem for batch folders\n          const clientPath = `/data/clients/${slug}`;\n          const fsBatches = [];\n\n          if (fs.existsSync(clientPath)) {\n            const entries = fs.readdirSync(clientPath, { withFileTypes: true });\n            for (const entry of entries) {\n              if (entry.isDirectory() \u0026\u0026 !entry.name.startsWith(\u0027_\u0027) \u0026\u0026 !entry.name.startsWith(\u0027.\u0027)) {\n                const batchPath = `${clientPath}/${entry.name}`;\n                const hasReady = fs.existsSync(`${batchPath}/READY.txt`);\n                const hasConfig = fs.existsSync(`${batchPath}/batch_config.yaml`) ||\n                                 fs.existsSync(`${batchPath}/batch.yaml`);\n\n                // Count media files\n                let photoCount = 0, videoCount = 0;\n                const photosPath = `${batchPath}/photos`;\n                const videosPath = `${batchPath}/videos`;\n                if (fs.existsSync(photosPath)) {\n                  photoCount = fs.readdirSync(photosPath).filter(f =\u003e /.(jpg|jpeg|png)$/i.test(f)).length;\n                }\n                if (fs.existsSync(videosPath)) {\n                  videoCount = fs.readdirSync(videosPath).filter(f =\u003e /.(mp4|mov)$/i.test(f)).length;\n                }\n\n                fsBatches.push({\n                  name: entry.name,\n                  slug: entry.name,\n                  has_ready: hasReady,\n                  has_config: hasConfig,\n                  photo_count: photoCount,\n                  video_count: videoCount,\n                  source: \u0027filesystem\u0027\n                });\n              }\n            }\n          }\n\n          // 2. Get database batches with status counts\n          const dbBatches = db.prepare(`\n            SELECT b.*,\n              (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id) as item_count,\n              (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id AND status = \u0027NEEDS_AI\u0027) as needs_ai,\n              (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id AND status = \u0027NEEDS_REVIEW\u0027) as needs_review,\n              (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id AND status = \u0027APPROVED\u0027) as approved,\n              (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id AND status = \u0027SCHEDULED\u0027) as scheduled\n            FROM batches b WHERE b.client_id = ?\n          `).all(client.id);\n\n          // 3. Merge: DB data enriches filesystem data\n          const merged = fsBatches.map(fsBatch =\u003e {\n            const dbBatch = dbBatches.find(d =\u003e d.slug === fsBatch.name);\n            if (dbBatch) {\n              return {\n                ...fsBatch,\n                id: dbBatch.id,\n                ingested: true,\n                item_count: dbBatch.item_count,\n                needs_ai: dbBatch.needs_ai || 0,\n                needs_review: dbBatch.needs_review || 0,\n                approved: dbBatch.approved || 0,\n                scheduled: dbBatch.scheduled || 0,\n                source: \u0027database\u0027\n              };\n            }\n            return { ...fsBatch, ingested: false, item_count: 0, needs_ai: 0, needs_review: 0, approved: 0, scheduled: 0 };\n          });\n\n          result = success({ batches: merged, client: slug }, `Found ${merged.length} batches`);\n        }\n      } finally {\n        db.close();\n      }\n    }\n    else {\n      result = error(`Invalid clients route: ${route}`, 400);\n    }\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // FILES - List uploaded files for a batch (v16)\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (base === \u0027files\u0027) {\n    const db = new Database(db_path, { readonly: true });\n    try {\n      // GET /files/:batch_id - List files for a batch\n      if (parts.length === 2) {\n        const batchId = parts[1];\n        const files = db.prepare(`\n          SELECT * FROM files WHERE batch_id = ? ORDER BY uploaded_at ASC\n        `).all(batchId);\n        result = success({ files }, `Found ${files.length} files`);\n      } else {\n        result = error(\u0027Batch ID required\u0027, 400);\n      }\n    } finally {\n      db.close();\n    }\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // BATCHES - Get batch details, list batches, status counts\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (base === \u0027batches\u0027) {\n    // POST /batches - Create new batch for upload-based onboarding (v16)\n    if (method === \u0027POST\u0027 \u0026\u0026 parts.length === 1) {\n      const { client_id, name, description, source_type } = body;\n      \n      if (!client_id || !name) {\n        result = error(\u0027client_id and name required\u0027, 400);\n      } else {\n        const dbWrite = new Database(db_path);\n        dbWrite.pragma(\u0027foreign_keys = ON\u0027);\n        \n        try {\n          // Verify client exists\n          const client = dbWrite.prepare(\u0027SELECT id, slug FROM clients WHERE id = ?\u0027).get(client_id);\n          if (!client) {\n            result = error(`Client not found: ${client_id}`, 404);\n          } else {\n            // Generate slug from name\n            const slug = name.toLowerCase()\n              .normalize(\u0027NFD\u0027).replace(/[\\u0300-\\u036f]/g, \u0027\u0027)\n              .replace(/[^a-z0-9]+/g, \u0027-\u0027)\n              .replace(/^-|-$/g, \u0027\u0027);\n            \n            // Check if batch exists\n            const existing = dbWrite.prepare(\u0027SELECT id FROM batches WHERE client_id = ? AND slug = ?\u0027).get(client_id, slug);\n            if (existing) {\n              result = error(`Batch already exists: ${slug}`, 409);\n            } else {\n              const info = dbWrite.prepare(`\n                INSERT INTO batches (client_id, slug, name, description, source_type, status, created_at)\n                VALUES (?, ?, ?, ?, ?, \u0027draft\u0027, datetime(\u0027now\u0027))\n              `).run(client_id, slug, name, description || \u0027\u0027, source_type || \u0027upload\u0027);\n              \n              result = success({ batch_id: info.lastInsertRowid, slug, client_slug: client.slug }, \u0027Batch created\u0027);\n            }\n          }\n        } finally {\n          dbWrite.close();\n        }\n      }\n    } else {\n    const db = new Database(db_path, { readonly: true });\n    try {\n      // GET /batches/:client/:batch/generation-progress - Get AI generation progress (v15)\n      if (parts.length === 4 \u0026\u0026 parts[3] === \u0027generation-progress\u0027) {\n        const clientSlug = parts[1];\n        const batchSlug = parts[2];\n        \n        const batch = db.prepare(`\n          SELECT b.id, b.generation_progress, b.generation_started_at FROM batches b\n          JOIN clients c ON b.client_id = c.id\n          WHERE c.slug = ? AND b.slug = ?\n        `).get(clientSlug, batchSlug);\n        \n        if (!batch) {\n          result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n        } else {\n          let progress = null;\n          if (batch.generation_progress) {\n            try {\n              progress = JSON.parse(batch.generation_progress);\n            } catch (e) {\n              progress = null;\n            }\n          }\n          result = success({\n            progress: progress,\n            started_at: batch.generation_started_at,\n            is_running: progress !== null\n          }, progress ? `Generating item ${progress.current}/${progress.total}` : \u0027No generation in progress\u0027);\n        }\n      }\n      // GET /batches/:client/:batch/ingest-progress - Get W1 ingest progress (v15.2)\n      else if (parts.length === 4 \u0026\u0026 parts[3] === \u0027ingest-progress\u0027) {\n        const clientSlug = parts[1];\n        const batchSlug = parts[2];\n        \n        const batch = db.prepare(`\n          SELECT b.id, b.ingest_progress, b.ingest_started_at FROM batches b\n          JOIN clients c ON b.client_id = c.id\n          WHERE c.slug = ? AND b.slug = ?\n        `).get(clientSlug, batchSlug);\n        \n        if (!batch) {\n          result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n        } else {\n          let progress = null;\n          if (batch.ingest_progress) {\n            try {\n              progress = JSON.parse(batch.ingest_progress);\n            } catch (e) {\n              progress = null;\n            }\n          }\n          result = success({\n            progress: progress,\n            started_at: batch.ingest_started_at,\n            is_running: progress !== null\n          }, progress ? `Processing ${progress.current}/${progress.total} (${progress.stage})` : \u0027No ingest in progress\u0027);\n        }\n      }\n      // GET /batches/:client/:batch/status - Get status counts for batch\n      else if (parts.length === 4 \u0026\u0026 parts[3] === \u0027status\u0027) {\n        const clientSlug = parts[1];\n        const batchSlug = parts[2];\n        \n        const batch = db.prepare(`\n          SELECT b.id FROM batches b\n          JOIN clients c ON b.client_id = c.id\n          WHERE c.slug = ? AND b.slug = ?\n        `).get(clientSlug, batchSlug);\n        \n        if (!batch) {\n          result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n        } else {\n          const counts = db.prepare(`\n            SELECT\n              COUNT(*) as total,\n              SUM(CASE WHEN status = \u0027PENDING\u0027 THEN 1 ELSE 0 END) as pending,\n              SUM(CASE WHEN status = \u0027NEEDS_AI\u0027 THEN 1 ELSE 0 END) as needs_ai,\n              SUM(CASE WHEN status = \u0027NEEDS_REVIEW\u0027 THEN 1 ELSE 0 END) as needs_review,\n              SUM(CASE WHEN status = \u0027APPROVED\u0027 THEN 1 ELSE 0 END) as approved,\n              SUM(CASE WHEN status = \u0027SCHEDULED\u0027 THEN 1 ELSE 0 END) as scheduled,\n              SUM(CASE WHEN status = \u0027FAILED\u0027 THEN 1 ELSE 0 END) as failed\n            FROM content_items WHERE batch_id = ?\n          `).get(batch.id);\n          result = success({ counts, client: clientSlug, batch: batchSlug });\n        }\n      }\n      // GET /batches/:client/:batch - Get batch details\n      else if (parts.length === 3) {\n        const clientSlug = parts[1];\n        const batchSlug = parts[2];\n        \n        const batch = db.prepare(`\n          SELECT b.*, c.slug as client_slug, c.name as client_name\n          FROM batches b\n          JOIN clients c ON b.client_id = c.id\n          WHERE c.slug = ? AND b.slug = ?\n        `).get(clientSlug, batchSlug);\n        \n        if (!batch) {\n          result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n        } else {\n          batch.hashtags = JSON.parse(batch.hashtags || \u0027[]\u0027);\n          batch.schedule_config = JSON.parse(batch.schedule_config || \u0027{}\u0027);\n          result = success(batch);\n        }\n      }\n      // GET /batches/:client - List all batches for a client\n      else if (parts.length === 2) {\n        const clientSlug = parts[1];\n        const client = db.prepare(\u0027SELECT id FROM clients WHERE slug = ?\u0027).get(clientSlug);\n        \n        if (!client) {\n          result = error(`Client not found: ${clientSlug}`, 404);\n        } else {\n          const batches = db.prepare(`\n            SELECT b.*,\n              (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id) as item_count,\n              (SELECT COUNT(*) FROM content_items WHERE batch_id = b.id AND status = \u0027NEEDS_REVIEW\u0027) as pending_review\n            FROM batches b\n            WHERE b.client_id = ?\n            ORDER BY b.created_at DESC\n          `).all(client.id);\n          \n          for (const batch of batches) {\n            batch.hashtags = JSON.parse(batch.hashtags || \u0027[]\u0027);\n            batch.schedule_config = JSON.parse(batch.schedule_config || \u0027{}\u0027);\n          }\n          \n          result = success({ batches, client: clientSlug }, `Found ${batches.length} batches`);\n        }\n      }\n      else {\n        result = error(\u0027Invalid batch route\u0027, 400);\n      }\n    } finally {\n      db.close();\n    }\n    }\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // ITEMS - Get content items for approval board\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (base === \u0027items\u0027) {\n    const db = new Database(db_path, { readonly: true });\n    try {\n      // GET /items/:client/:batch/:content_id/conversations - Get AI conversation logs (v15)\n      if (parts.length === 5 \u0026\u0026 parts[4] === \u0027conversations\u0027) {\n        const clientSlug = parts[1];\n        const batchSlug = parts[2];\n        const contentId = parts[3];\n        \n        // Verify the content item exists\n        const item = db.prepare(`\n          SELECT ci.id, ci.content_id FROM content_items ci\n          JOIN clients c ON ci.client_id = c.id\n          JOIN batches b ON ci.batch_id = b.id\n          WHERE c.slug = ? AND b.slug = ? AND ci.content_id = ?\n        `).get(clientSlug, batchSlug, contentId);\n        \n        if (!item) {\n          result = error(`Content item not found: ${clientSlug}/${batchSlug}/${contentId}`, 404);\n        } else {\n          const conversations = db.prepare(`\n            SELECT * FROM ai_conversations\n            WHERE content_id = ?\n            ORDER BY session_id, round_number, role\n          `).all(contentId);\n          \n          // Group by session for easier UI display\n          const sessions = {};\n          for (const conv of conversations) {\n            if (!sessions[conv.session_id]) {\n              sessions[conv.session_id] = {\n                session_id: conv.session_id,\n                rounds: []\n              };\n            }\n            sessions[conv.session_id].rounds.push(conv);\n          }\n          \n          result = success({\n            content_id: contentId,\n            sessions: Object.values(sessions),\n            total_conversations: conversations.length\n          }, `Found ${conversations.length} conversation entries`);\n        }\n      }\n      // GET /items/:client/:batch - List items\n      else if (parts.length \u003e= 3) {\n        const clientSlug = parts[1];\n        const batchSlug = parts[2];\n        const statusFilter = query.status || null;\n        const rawLimit = parseInt(query.limit || \u0027100\u0027, 10);\n        const rawOffset = parseInt(query.offset || \u00270\u0027, 10);\n        // Bounds checking: limit 1-1000, offset \u003e= 0\n        const limit = Math.min(1000, Math.max(1, isNaN(rawLimit) ? 100 : rawLimit));\n        const offset = Math.max(0, isNaN(rawOffset) ? 0 : rawOffset);\n        \n        // Validate status filter (whitelist to prevent SQL injection)\n        if (statusFilter \u0026\u0026 !VALID_STATUSES.includes(statusFilter)) {\n          result = error(`Invalid status filter: ${statusFilter}. Valid values: ${VALID_STATUSES.join(\u0027, \u0027)}`, 400);\n          db.close();\n          return [{ json: result }];\n        }\n        \n        // Load current Cloudflare URL for dynamic URL reconstruction\n        const settingsPath = `${config_base}/settings.json`;\n        let cloudflareUrl = \u0027\u0027;\n        try {\n          if (fs.existsSync(settingsPath)) {\n            const settings = JSON.parse(fs.readFileSync(settingsPath, \u0027utf8\u0027));\n            cloudflareUrl = settings.cloudflare_tunnel_url || \u0027\u0027;\n          }\n        } catch (e) {\n          console.log(\u0027[API] Warning: Could not load Cloudflare URL from settings\u0027);\n        }\n        \n        let queryStr = `\n          SELECT ci.*, c.slug as client_slug, b.slug as batch_slug,\n                 b.source_type, f.storage_path as upload_path, f.uuid as file_uuid\n          FROM content_items ci\n          JOIN clients c ON ci.client_id = c.id\n          JOIN batches b ON ci.batch_id = b.id\n          LEFT JOIN files f ON ci.file_id = f.id\n          WHERE c.slug = ? AND b.slug = ? AND ci.status != \u0027DELETED\u0027\n        `;\n        const params = [clientSlug, batchSlug];\n        \n        if (statusFilter) {\n          queryStr += \u0027 AND ci.status = ?\u0027;\n          params.push(statusFilter);\n        }\n        \n        queryStr += \u0027 ORDER BY ci.scheduled_date, ci.scheduled_time LIMIT ? OFFSET ?\u0027;\n        params.push(limit, offset);\n        \n        const items = db.prepare(queryStr).all(...params);\n        \n        // Rebuild media URLs with current Cloudflare URL (v16: source_type aware)\n        if (cloudflareUrl) {\n          for (const item of items) {\n            const cacheBuster = item.file_hash ? `?v=${item.file_hash.substring(0, 8)}` : `?t=${Date.now()}`;\n            if (item.source_type === \u0027upload\u0027 \u0026\u0026 item.upload_path) {\n              // Upload-based batch: serve from /uploads/ directory\n              const ext = item.file_name ? item.file_name.match(/\\.[^.]+$/)?.[0] || \u0027\u0027 : \u0027\u0027;\n              item.media_url = `${cloudflareUrl}/uploads/${item.client_id}/${item.batch_id}/${item.file_uuid}${ext}${cacheBuster}`;\n            } else {\n              // Folder-based batch: serve from /{client}/{batch}/photos|videos/\n              const mediaFolder = item.media_type === \u0027photo\u0027 ? \u0027photos\u0027 : \u0027videos\u0027;\n              item.media_url = `${cloudflareUrl}/${item.client_slug}/${item.batch_slug}/${mediaFolder}/${item.file_name}${cacheBuster}`;\n            }\n            item.preview_url = item.media_url;\n          }\n        }\n        \n        // Get total count\n        let countQuery = `\n          SELECT COUNT(*) as total\n          FROM content_items ci\n          JOIN clients c ON ci.client_id = c.id\n          JOIN batches b ON ci.batch_id = b.id\n          WHERE c.slug = ? AND b.slug = ? AND ci.status != \u0027DELETED\u0027\n        `;\n        const countParams = [clientSlug, batchSlug];\n        if (statusFilter) {\n          countQuery += \u0027 AND ci.status = ?\u0027;\n          countParams.push(statusFilter);\n        }\n        const totalCount = db.prepare(countQuery).get(...countParams).total;\n        \n        result = success({\n          items: items,\n          pagination: {\n            total: totalCount,\n            limit: limit,\n            offset: offset,\n            has_more: offset + items.length \u003c totalCount\n          }\n        }, `Found ${items.length} items`);\n      } else {\n        result = error(\u0027Items route requires client and batch slug\u0027, 400);\n      }\n    } finally {\n      db.close();\n    }\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // ITEM - Single item operations\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (base === \u0027item\u0027) {\n    if (parts.length \u003c 2) {\n      result = error(\u0027Item ID required\u0027, 400);\n    } else {\n      const itemId = parts[1];\n      const action = parts[2] || null;\n      \n      const db = new Database(db_path);\n      db.pragma(\u0027foreign_keys = ON\u0027);\n      \n      try {\n        // Get item by ID or content_id\n        let item = db.prepare(\u0027SELECT * FROM content_items WHERE id = ? OR content_id = ?\u0027).get(itemId, itemId);\n        \n        if (!item) {\n          result = error(`Item not found: ${itemId}`, 404);\n        }\n        // DELETE /item/:id - Soft delete item\n        else if (!action \u0026\u0026 method === \u0027DELETE\u0027) {\n          db.prepare(\"UPDATE content_items SET status = \u0027DELETED\u0027 WHERE id = ?\").run(item.id);\n          \n          db.prepare(`\n            INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n            VALUES (\u0027content_item\u0027, ?, \u0027delete\u0027, ?, datetime(\u0027now\u0027))\n          `).run(item.id, body.user_id || \u0027api\u0027);\n          \n          result = success({ id: item.id }, \u0027Item deleted\u0027);\n        }\n        // GET /item/:id - Return item\n        else if (!action) {\n          result = success(item);\n        }\n        // POST /item/:id/approve\n        else if (action === \u0027approve\u0027 \u0026\u0026 method === \u0027POST\u0027) {\n          const fileHash = item.file_hash || \u0027\u0027;\n          \n          db.prepare(`\n            UPDATE content_items\n            SET status = \u0027APPROVED\u0027,\n                approved_at = datetime(\u0027now\u0027),\n                approved_by = ?,\n                approved_file_hash = ?\n            WHERE id = ?\n          `).run(body.user_id || \u0027api\u0027, fileHash, item.id);\n          \n          db.prepare(`\n            INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n            VALUES (\u0027content_item\u0027, ?, \u0027approve\u0027, ?, datetime(\u0027now\u0027))\n          `).run(item.id, body.user_id || \u0027api\u0027);\n          \n          item = db.prepare(\u0027SELECT * FROM content_items WHERE id = ?\u0027).get(item.id);\n          result = success(item, \u0027Item approved\u0027);\n        }\n        // POST /item/:id/reject\n        else if (action === \u0027reject\u0027 \u0026\u0026 method === \u0027POST\u0027) {\n          const reason = body.reason || \u0027Rejected by user\u0027;\n          \n          db.prepare(`\n            UPDATE content_items\n            SET status = \u0027REJECTED\u0027,\n                error_message = ?\n            WHERE id = ?\n          `).run(reason, item.id);\n          \n          db.prepare(`\n            INSERT INTO audit_log (entity_type, entity_id, action, new_value, user_id, created_at)\n            VALUES (\u0027content_item\u0027, ?, \u0027reject\u0027, ?, ?, datetime(\u0027now\u0027))\n          `).run(item.id, reason, body.user_id || \u0027api\u0027);\n          \n          item = db.prepare(\u0027SELECT * FROM content_items WHERE id = ?\u0027).get(item.id);\n          result = success(item, \u0027Item rejected\u0027);\n        }\n        // POST /item/:id/caption\n        else if (action === \u0027caption\u0027 \u0026\u0026 method === \u0027POST\u0027) {\n          const captionIg = body.caption_ig !== undefined ? body.caption_ig : item.caption_ig;\n          const captionTt = body.caption_tt !== undefined ? body.caption_tt : item.caption_tt;\n          const hashtags = body.hashtags_final !== undefined ? body.hashtags_final : item.hashtags_final;\n          \n          db.prepare(`\n            UPDATE content_items\n            SET caption_ig = ?,\n                caption_tt = ?,\n                hashtags_final = ?\n            WHERE id = ?\n          `).run(captionIg, captionTt, hashtags, item.id);\n          \n          db.prepare(`\n            INSERT INTO audit_log (entity_type, entity_id, action, field_changed, new_value, user_id, created_at)\n            VALUES (\u0027content_item\u0027, ?, \u0027update\u0027, \u0027caption\u0027, ?, ?, datetime(\u0027now\u0027))\n          `).run(item.id, (captionIg || \u0027\u0027).substring(0, 200), body.user_id || \u0027api\u0027);\n          \n          item = db.prepare(\u0027SELECT * FROM content_items WHERE id = ?\u0027).get(item.id);\n          result = success(item, \u0027Caption updated\u0027);\n        }\n        // POST /item/:id/regenerate - Queue for AI regeneration\n        else if (action === \u0027regenerate\u0027 \u0026\u0026 method === \u0027POST\u0027) {\n          db.prepare(`\n            UPDATE content_items\n            SET status = \u0027NEEDS_AI\u0027,\n                caption_ig = NULL,\n                caption_tt = NULL,\n                error_message = NULL\n            WHERE id = ?\n          `).run(item.id);\n          \n          db.prepare(`\n            INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n            VALUES (\u0027content_item\u0027, ?, \u0027regenerate\u0027, ?, datetime(\u0027now\u0027))\n          `).run(item.id, body.user_id || \u0027api\u0027);\n          \n          item = db.prepare(\u0027SELECT * FROM content_items WHERE id = ?\u0027).get(item.id);\n          result = success(item, \u0027Item queued for caption regeneration. Run W2-Captions to process.\u0027);\n        }\n        // POST /item/:id/reschedule - Change schedule date/time\n        else if (action === \u0027reschedule\u0027 \u0026\u0026 method === \u0027POST\u0027) {\n          const { scheduled_date, scheduled_time, schedule_at } = body;\n          \n          if (!scheduled_date \u0026\u0026 !schedule_at) {\n            result = error(\u0027scheduled_date or schedule_at required\u0027, 400);\n          } else {\n            const updates = [];\n            const params = [];\n            \n            if (scheduled_date) { updates.push(\u0027scheduled_date = ?\u0027); params.push(scheduled_date); }\n            if (scheduled_time) { updates.push(\u0027scheduled_time = ?\u0027); params.push(scheduled_time); }\n            if (schedule_at) { updates.push(\u0027schedule_at = ?\u0027); params.push(schedule_at); }\n            \n            // If item was already SCHEDULED, reset to APPROVED\n            if (item.status === \u0027SCHEDULED\u0027) {\n              updates.push(\"status = \u0027APPROVED\u0027\");\n              updates.push(\u0027late_post_id = NULL\u0027);\n            }\n            \n            params.push(item.id);\n            db.prepare(`UPDATE content_items SET ${updates.join(\u0027, \u0027)} WHERE id = ?`).run(...params);\n            \n            db.prepare(`\n              INSERT INTO audit_log (entity_type, entity_id, action, field_changed, new_value, user_id, created_at)\n              VALUES (\u0027content_item\u0027, ?, \u0027reschedule\u0027, \u0027schedule_at\u0027, ?, ?, datetime(\u0027now\u0027))\n            `).run(item.id, schedule_at || scheduled_date, body.user_id || \u0027api\u0027);\n            \n            item = db.prepare(\u0027SELECT * FROM content_items WHERE id = ?\u0027).get(item.id);\n            result = success(item, \u0027Item rescheduled\u0027);\n          }\n        }\n        else {\n          result = error(`Unknown action: ${action}`, 400);\n        }\n      } finally {\n        db.close();\n      }\n    }\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // APPROVE BATCH - Approve multiple items\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (base === \u0027approve-batch\u0027 \u0026\u0026 method === \u0027POST\u0027) {\n    const ids = body.ids || [];\n    \n    if (!Array.isArray(ids) || ids.length === 0) {\n      result = error(\u0027ids array required\u0027, 400);\n    } else {\n      const db = new Database(db_path);\n      db.pragma(\u0027foreign_keys = ON\u0027);\n      \n      try {\n        const updateStmt = db.prepare(`\n          UPDATE content_items\n          SET status = \u0027APPROVED\u0027,\n              approved_at = datetime(\u0027now\u0027),\n              approved_by = ?,\n              approved_file_hash = file_hash\n          WHERE (id = ? OR content_id = ?) AND status IN (\u0027NEEDS_REVIEW\u0027, \u0027NEEDS_AI\u0027)\n        `);\n        \n        const auditStmt = db.prepare(`\n          INSERT INTO audit_log (entity_type, entity_id, action, user_id, created_at)\n          SELECT \u0027content_item\u0027, id, \u0027approve\u0027, ?, datetime(\u0027now\u0027)\n          FROM content_items WHERE id = ? OR content_id = ?\n        `);\n        \n        let approved = 0;\n        \n        const approveMany = db.transaction((ids) =\u003e {\n          for (const id of ids) {\n            const info = updateStmt.run(body.user_id || \u0027api\u0027, id, id);\n            if (info.changes \u003e 0) {\n              approved++;\n              auditStmt.run(body.user_id || \u0027api\u0027, id, id);\n            }\n          }\n        });\n        \n        approveMany(ids);\n        \n        result = success({ approved: approved, total: ids.length }, `Approved ${approved} items`);\n      } finally {\n        db.close();\n      }\n    }\n  }\n  \n\n    // ============================================\n    // ARCHIVE ENDPOINTS\n    // ============================================\n\n    // POST /clients/:slug/archive - Archive a client\n    else if (method === \u0027POST\u0027 \u0026\u0026 parts.length === 3 \u0026\u0026 parts[2] === \u0027archive\u0027) {\n      const slug = parts[1];\n      const archivePath = db_path.replace(\u0027socialflow.db\u0027, \u0027socialflow_archive.db\u0027);\n      \n      if (!fs.existsSync(archivePath)) {\n        result = error(\u0027Archive database not initialized. Run init_archive_database.js first.\u0027, 500);\n      } else {\n      const db = new Database(db_path);\n      const archiveDb = new Database(archivePath);\n      db.pragma(\u0027foreign_keys = ON\u0027);\n\n      try {\n        const client = db.prepare(\u0027SELECT * FROM clients WHERE slug = ?\u0027).get(slug);\n\n        if (!client) {\n          result = error(`Client not found: ${slug}`, 404);\n        } else {\n          // Insert into archive\n          archiveDb.prepare(`\n            INSERT INTO archived_clients (id, slug, name, language, timezone, type, brand_voice,\n              brand_target_audience, brand_description, hashtags, platform_defaults, policy, original_created_at)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n          `).run(client.id, client.slug, client.name, client.language, client.timezone, client.type,\n            client.brand_voice, client.brand_target_audience, client.brand_description,\n            client.hashtags, client.platform_defaults, client.policy, client.created_at);\n\n          // Archive accounts\n          const accounts = db.prepare(\u0027SELECT * FROM accounts WHERE client_id = ?\u0027).all(client.id);\n          for (const acc of accounts) {\n            archiveDb.prepare(`\n              INSERT INTO archived_accounts (id, archived_client_id, platform, late_account_id,\n                username, display_name, profile_picture_url, original_created_at)\n              VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n            `).run(acc.id, client.id, acc.platform, acc.late_account_id,\n              acc.username, acc.display_name, acc.profile_picture_url, acc.created_at);\n          }\n\n          // Archive batches\n          const batches = db.prepare(\u0027SELECT * FROM batches WHERE client_id = ?\u0027).all(client.id);\n          for (const batch of batches) {\n            archiveDb.prepare(`\n              INSERT INTO archived_batches (id, archived_client_id, slug, name, description,\n                brief, hashtags, schedule_config, folder_path, status, original_created_at)\n              VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n            `).run(batch.id, client.id, batch.slug, batch.name, batch.description,\n              batch.brief, batch.hashtags, batch.schedule_config, batch.folder_path, batch.status, batch.created_at);\n\n            // Archive content items for this batch\n            const items = db.prepare(\u0027SELECT * FROM content_items WHERE batch_id = ?\u0027).all(batch.id);\n            for (const item of items) {\n              archiveDb.prepare(`\n                INSERT INTO archived_content_items (id, content_id, archived_client_id, archived_batch_id,\n                  media_type, file_name, file_path, file_hash, scheduled_date, scheduled_time,\n                  caption_ig, caption_tt, caption_override, hashtags_final, status, late_post_id, original_created_at)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n              `).run(item.id, item.content_id, client.id, batch.id,\n                item.media_type, item.file_name, item.file_path, item.file_hash,\n                item.scheduled_date, item.scheduled_time, item.caption_ig, item.caption_tt,\n                item.caption_override, item.hashtags_final, item.status, item.late_post_id, item.created_at);\n            }\n          }\n\n          // Delete from main database (cascades to accounts, batches, content_items)\n          db.prepare(\u0027DELETE FROM clients WHERE id = ?\u0027).run(client.id);\n\n          result = success({ slug, archived_at: new Date().toISOString() }, \u0027Client archived\u0027);\n        }\n      } finally {\n        db.close();\n        archiveDb.close();\n      }\n      }\n    }\n\n    // GET /archive/clients - List archived clients\n    else if (base === \u0027archive\u0027 \u0026\u0026 parts.length === 2 \u0026\u0026 parts[1] === \u0027clients\u0027) {\n      const archivePath = db_path.replace(\u0027socialflow.db\u0027, \u0027socialflow_archive.db\u0027);\n      \n      if (!fs.existsSync(archivePath)) {\n        result = success([], \u0027No archived clients (archive database not initialized)\u0027);\n      } else {\n      const archiveDb = new Database(archivePath, { readonly: true });\n\n      try {\n        const clients = archiveDb.prepare(`\n          SELECT ac.*,\n            (SELECT COUNT(*) FROM archived_batches WHERE archived_client_id = ac.id) as batch_count,\n            (SELECT COUNT(*) FROM archived_content_items WHERE archived_client_id = ac.id) as item_count\n          FROM archived_clients ac\n          ORDER BY ac.archived_at DESC\n        `).all();\n\n        result = success(clients, `Found ${clients.length} archived clients`);\n      } finally {\n        archiveDb.close();\n      }\n      }\n    }\n\n    // POST /archive/clients/:id/restore - Restore an archived client\n    else if (method === \u0027POST\u0027 \u0026\u0026 base === \u0027archive\u0027 \u0026\u0026 parts.length === 4 \u0026\u0026 parts[3] === \u0027restore\u0027) {\n      const archivedId = parseInt(parts[2]);\n      const db = new Database(db_path);\n      const archiveDb = new Database(db_path.replace(\u0027socialflow.db\u0027, \u0027socialflow_archive.db\u0027));\n      db.pragma(\u0027foreign_keys = ON\u0027);\n\n      try {\n        const archived = archiveDb.prepare(\u0027SELECT * FROM archived_clients WHERE id = ?\u0027).get(archivedId);\n\n        if (!archived) {\n          result = error(`Archived client not found: ${archivedId}`, 404);\n        } else {\n          // Check if slug already exists in main db\n          const existing = db.prepare(\u0027SELECT id FROM clients WHERE slug = ?\u0027).get(archived.slug);\n          if (existing) {\n            result = error(`Client with slug \u0027${archived.slug}\u0027 already exists. Delete it first or rename.`, 409);\n          } else {\n            // Restore client\n            db.prepare(`\n              INSERT INTO clients (id, slug, name, language, timezone, type, brand_voice,\n                brand_target_audience, brand_description, hashtags, platform_defaults, policy,\n                is_active, created_at, updated_at)\n              VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 1, ?, datetime(\u0027now\u0027))\n            `).run(archived.id, archived.slug, archived.name, archived.language, archived.timezone,\n              archived.type, archived.brand_voice, archived.brand_target_audience, archived.brand_description,\n              archived.hashtags, archived.platform_defaults, archived.policy, archived.original_created_at);\n\n            // Restore accounts\n            const archivedAccounts = archiveDb.prepare(\u0027SELECT * FROM archived_accounts WHERE archived_client_id = ?\u0027).all(archivedId);\n            for (const acc of archivedAccounts) {\n              db.prepare(`\n                INSERT INTO accounts (id, client_id, platform, late_account_id, username,\n                  display_name, profile_picture_url, is_active, created_at, updated_at)\n                VALUES (?, ?, ?, ?, ?, ?, ?, 1, ?, datetime(\u0027now\u0027))\n              `).run(acc.id, archived.id, acc.platform, acc.late_account_id, acc.username,\n                acc.display_name, acc.profile_picture_url, acc.original_created_at);\n            }\n\n            // Restore batches\n            const archivedBatches = archiveDb.prepare(\u0027SELECT * FROM archived_batches WHERE archived_client_id = ?\u0027).all(archivedId);\n            for (const batch of archivedBatches) {\n              db.prepare(`\n                INSERT INTO batches (id, client_id, slug, name, description, brief, hashtags,\n                  schedule_config, folder_path, status, created_at, updated_at)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime(\u0027now\u0027))\n              `).run(batch.id, archived.id, batch.slug, batch.name, batch.description,\n                batch.brief, batch.hashtags, batch.schedule_config, batch.folder_path,\n                batch.status, batch.original_created_at);\n\n              // Restore content items\n              const archivedItems = archiveDb.prepare(\u0027SELECT * FROM archived_content_items WHERE archived_batch_id = ?\u0027).all(batch.id);\n              for (const item of archivedItems) {\n                db.prepare(`\n                  INSERT INTO content_items (id, content_id, client_id, batch_id, media_type,\n                    file_name, file_path, file_hash, scheduled_date, scheduled_time,\n                    caption_ig, caption_tt, caption_override, hashtags_final, status,\n                    late_post_id, created_at, updated_at)\n                  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime(\u0027now\u0027))\n                `).run(item.id, item.content_id, archived.id, batch.id, item.media_type,\n                  item.file_name, item.file_path, item.file_hash, item.scheduled_date, item.scheduled_time,\n                  item.caption_ig, item.caption_tt, item.caption_override, item.hashtags_final,\n                  item.status, item.late_post_id, item.original_created_at);\n              }\n            }\n\n            // Delete from archive\n            archiveDb.prepare(\u0027DELETE FROM archived_clients WHERE id = ?\u0027).run(archivedId);\n\n            result = success({ slug: archived.slug, restored_at: new Date().toISOString() }, \u0027Client restored\u0027);\n          }\n        }\n      } finally {\n        db.close();\n        archiveDb.close();\n      }\n    }\n\n    // DELETE /archive/clients/:id - Permanently delete archived client\n    else if (method === \u0027DELETE\u0027 \u0026\u0026 base === \u0027archive\u0027 \u0026\u0026 parts.length === 3 \u0026\u0026 parts[1] === \u0027clients\u0027) {\n      const archivedId = parseInt(parts[2]);\n      const archiveDb = new Database(db_path.replace(\u0027socialflow.db\u0027, \u0027socialflow_archive.db\u0027));\n\n      try {\n        const archived = archiveDb.prepare(\u0027SELECT slug FROM archived_clients WHERE id = ?\u0027).get(archivedId);\n\n        if (!archived) {\n          result = error(`Archived client not found: ${archivedId}`, 404);\n        } else {\n          archiveDb.prepare(\u0027DELETE FROM archived_clients WHERE id = ?\u0027).run(archivedId);\n          result = success({ id: archivedId, slug: archived.slug }, \u0027Archived client permanently deleted\u0027);\n        }\n      } finally {\n        archiveDb.close();\n      }\n    }\n\n\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // AGENTS - Agent settings and instruction management (Phase 3)\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (base === \u0027agents\u0027) {\n    const agentsPath = `${config_base}/agents`;\n    const settingsPath = `${config_base}/settings.json`;\n    \n    // GET /agents/settings - Get agent models and master prompts\n    if (parts[1] === \u0027settings\u0027 \u0026\u0026 method === \u0027GET\u0027) {\n      try {\n        const settings = fs.existsSync(settingsPath) ? JSON.parse(fs.readFileSync(settingsPath, \u0027utf8\u0027)) : {};\n        const agents = {};\n        \n        // Config Generator\n        const configGenPath = `${agentsPath}/config_generator.md`;\n        agents.config_generator = {\n          model: settings.ollama?.models?.config_generator || settings.ollama?.model || \u0027llama3.2:3b\u0027,\n          master_prompt: fs.existsSync(configGenPath) ? fs.readFileSync(configGenPath, \u0027utf8\u0027) : \u0027\u0027\n        };\n        \n        // Caption Generator\n        const captionGenPath = `${agentsPath}/caption_generator.md`;\n        agents.caption_generator = {\n          model: settings.ollama?.models?.caption_generator || settings.ollama?.model || \u0027llava:7b\u0027,\n          master_prompt: fs.existsSync(captionGenPath) ? fs.readFileSync(captionGenPath, \u0027utf8\u0027) : \u0027\u0027\n        };\n        \n        result = success(agents, \u0027Agent settings loaded\u0027);\n      } catch (e) {\n        result = error(`Failed to load agent settings: ${e.message}`, 500);\n      }\n    }\n    // PUT /agents/settings - Update agent model or master prompt\n    else if (parts[1] === \u0027settings\u0027 \u0026\u0026 method === \u0027PUT\u0027) {\n      try {\n        const { agent_type, model, master_prompt } = body;\n        \n        if (!agent_type || ![\u0027config_generator\u0027, \u0027caption_generator\u0027].includes(agent_type)) {\n          result = error(\u0027agent_type must be config_generator or caption_generator\u0027, 400);\n        } else {\n          // Update model in settings.json if provided\n          if (model !== undefined) {\n            const settings = fs.existsSync(settingsPath) ? JSON.parse(fs.readFileSync(settingsPath, \u0027utf8\u0027)) : {};\n            if (!settings.ollama) settings.ollama = {};\n            if (!settings.ollama.models) settings.ollama.models = {};\n            settings.ollama.models[agent_type] = model;\n            fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));\n          }\n          \n          // Update master prompt file if provided\n          if (master_prompt !== undefined) {\n            if (!fs.existsSync(agentsPath)) fs.mkdirSync(agentsPath, { recursive: true });\n            fs.writeFileSync(`${agentsPath}/${agent_type}.md`, master_prompt);\n          }\n          \n          result = success({ agent_type, updated: { model: model !== undefined, master_prompt: master_prompt !== undefined } }, \u0027Agent settings updated\u0027);\n        }\n      } catch (e) {\n        result = error(`Failed to update agent settings: ${e.message}`, 500);\n      }\n    }\n    // GET /agents/instructions - Get system-level instructions\n    else if (parts[1] === \u0027instructions\u0027 \u0026\u0026 method === \u0027GET\u0027) {\n      const db = new Database(db_path, { readonly: true });\n      try {\n        const instructions = db.prepare(`\n          SELECT * FROM agent_instructions\n          WHERE scope = \u0027system\u0027 AND is_active = 1\n          ORDER BY agent_type\n        `).all();\n        result = success(instructions, `Found ${instructions.length} system instructions`);\n      } finally {\n        db.close();\n      }\n    }\n    // PUT /agents/instructions - Upsert system-level instruction\n    else if (parts[1] === \u0027instructions\u0027 \u0026\u0026 method === \u0027PUT\u0027) {\n      const db = new Database(db_path);\n      db.pragma(\u0027foreign_keys = ON\u0027);\n      \n      try {\n        const { agent_type, instruction_key, instruction_value } = body;\n        \n        if (!agent_type || !instruction_key) {\n          result = error(\u0027agent_type and instruction_key are required\u0027, 400);\n        } else {\n          db.prepare(`\n            INSERT INTO agent_instructions (agent_type, scope, scope_id, instruction_key, instruction_value, is_active, updated_at)\n            VALUES (?, \u0027system\u0027, NULL, ?, ?, 1, datetime(\u0027now\u0027))\n            ON CONFLICT(agent_type, scope, scope_id, instruction_key)\n            DO UPDATE SET instruction_value = excluded.instruction_value, updated_at = datetime(\u0027now\u0027)\n          `).run(agent_type, instruction_key, instruction_value || \u0027\u0027);\n          \n          result = success({ agent_type, instruction_key }, \u0027System instruction saved\u0027);\n        }\n      } finally {\n        db.close();\n      }\n    }\n    else {\n      result = error(`Unknown agents route: ${route}`, 404);\n    }\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // CLIENT INSTRUCTIONS - Client-level AI instructions\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (parts.length === 3 \u0026\u0026 parts[0] === \u0027clients\u0027 \u0026\u0026 parts[2] === \u0027instructions\u0027) {\n    const clientSlug = parts[1];\n    const db = new Database(db_path);\n    db.pragma(\u0027foreign_keys = ON\u0027);\n    \n    try {\n      const client = db.prepare(\u0027SELECT id FROM clients WHERE slug = ?\u0027).get(clientSlug);\n      \n      if (!client) {\n        result = error(`Client not found: ${clientSlug}`, 404);\n      }\n      // GET /clients/:slug/instructions\n      else if (method === \u0027GET\u0027) {\n        const instructions = db.prepare(`\n          SELECT * FROM agent_instructions\n          WHERE scope = \u0027client\u0027 AND scope_id = ? AND is_active = 1\n          ORDER BY agent_type\n        `).all(client.id);\n        result = success(instructions, `Found ${instructions.length} client instructions`);\n      }\n      // PUT /clients/:slug/instructions\n      else if (method === \u0027PUT\u0027) {\n        const { agent_type, instruction_key, instruction_value } = body;\n        \n        if (!agent_type || !instruction_key) {\n          result = error(\u0027agent_type and instruction_key are required\u0027, 400);\n        } else {\n          db.prepare(`\n            INSERT INTO agent_instructions (agent_type, scope, scope_id, instruction_key, instruction_value, is_active, updated_at)\n            VALUES (?, \u0027client\u0027, ?, ?, ?, 1, datetime(\u0027now\u0027))\n            ON CONFLICT(agent_type, scope, scope_id, instruction_key)\n            DO UPDATE SET instruction_value = excluded.instruction_value, updated_at = datetime(\u0027now\u0027)\n          `).run(agent_type, client.id, instruction_key, instruction_value || \u0027\u0027);\n          \n          result = success({ agent_type, instruction_key, client: clientSlug }, \u0027Client instruction saved\u0027);\n        }\n      }\n      else {\n        result = error(\u0027Method not allowed\u0027, 405);\n      }\n    } finally {\n      db.close();\n    }\n  }\n  \n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // BATCH SCHEDULE - Bulk update content item schedules\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (parts.length === 4 \u0026\u0026 parts[0] === \u0027batches\u0027 \u0026\u0026 parts[3] === \u0027schedule\u0027 \u0026\u0026 method === \u0027POST\u0027) {\n    const clientSlug = parts[1];\n    const batchSlug = parts[2];\n    const db = new Database(db_path);\n    db.pragma(\u0027foreign_keys = ON\u0027);\n    \n    try {\n      const batch = db.prepare(`\n        SELECT b.id FROM batches b\n        JOIN clients c ON b.client_id = c.id\n        WHERE c.slug = ? AND b.slug = ?\n      `).get(clientSlug, batchSlug);\n      \n      if (!batch) {\n        result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n      } else if (!Array.isArray(body.items) || body.items.length === 0) {\n        result = error(\u0027items array is required\u0027, 400);\n      } else {\n        // Validate all schedule items before processing\n        try {\n          for (const item of body.items) {\n            validateScheduleItem(item);\n          }\n        } catch (validationError) {\n          result = error(validationError.message, 400);\n          db.close();\n          return [{ json: result }];\n        }\n        \n        const timezone = body.timezone || \u0027Europe/Berlin\u0027;\n        const updateStmt = db.prepare(`\n          UPDATE content_items\n          SET scheduled_date = ?,\n              scheduled_time = ?,\n              schedule_at = ?,\n              slot = ?,\n              updated_at = datetime(\u0027now\u0027)\n          WHERE (id = ? OR content_id = ?)\n            AND batch_id = ?\n            AND status IN (\u0027APPROVED\u0027, \u0027SCHEDULED\u0027)\n        `);\n        \n        let updated = 0;\n        const updateMany = db.transaction((items) =\u003e {\n          for (const item of items) {\n            const scheduleAt = `${item.scheduled_date}T${item.scheduled_time}`;\n            const info = updateStmt.run(\n              item.scheduled_date,\n              item.scheduled_time,\n              scheduleAt,\n              item.slot || \u0027feed\u0027,\n              item.id, String(item.id),\n              batch.id\n            );\n            if (info.changes \u003e 0) updated++;\n          }\n        });\n        \n        updateMany(body.items);\n        \n        result = success({ updated, total: body.items.length }, `Updated schedule for ${updated} items`);\n      }\n    } finally {\n      db.close();\n    }\n  }\n\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // BATCH INSTRUCTIONS - Batch-level AI instructions\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else if (parts.length === 4 \u0026\u0026 parts[0] === \u0027batches\u0027 \u0026\u0026 parts[3] === \u0027instructions\u0027) {\n    const clientSlug = parts[1];\n    const batchSlug = parts[2];\n    const db = new Database(db_path);\n    db.pragma(\u0027foreign_keys = ON\u0027);\n    \n    try {\n      const batch = db.prepare(`\n        SELECT b.id FROM batches b\n        JOIN clients c ON b.client_id = c.id\n        WHERE c.slug = ? AND b.slug = ?\n      `).get(clientSlug, batchSlug);\n      \n      if (!batch) {\n        result = error(`Batch not found: ${clientSlug}/${batchSlug}`, 404);\n      }\n      // GET /batches/:client/:batch/instructions\n      else if (method === \u0027GET\u0027) {\n        const instructions = db.prepare(`\n          SELECT * FROM agent_instructions\n          WHERE scope = \u0027batch\u0027 AND scope_id = ? AND is_active = 1\n          ORDER BY agent_type\n        `).all(batch.id);\n        result = success(instructions, `Found ${instructions.length} batch instructions`);\n      }\n      // PUT /batches/:client/:batch/instructions\n      else if (method === \u0027PUT\u0027) {\n        const { agent_type, instruction_key, instruction_value } = body;\n        \n        if (!agent_type || !instruction_key) {\n          result = error(\u0027agent_type and instruction_key are required\u0027, 400);\n        } else {\n          db.prepare(`\n            INSERT INTO agent_instructions (agent_type, scope, scope_id, instruction_key, instruction_value, is_active, updated_at)\n            VALUES (?, \u0027batch\u0027, ?, ?, ?, 1, datetime(\u0027now\u0027))\n            ON CONFLICT(agent_type, scope, scope_id, instruction_key)\n            DO UPDATE SET instruction_value = excluded.instruction_value, updated_at = datetime(\u0027now\u0027)\n          `).run(agent_type, batch.id, instruction_key, instruction_value || \u0027\u0027);\n          \n          result = success({ agent_type, instruction_key, client: clientSlug, batch: batchSlug }, \u0027Batch instruction saved\u0027);\n        }\n      }\n      else {\n        result = error(\u0027Method not allowed\u0027, 405);\n      }\n    } finally {\n      db.close();\n    }\n  }\n\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // UNKNOWN ROUTE\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  else {\n    result = error(`Unknown route: ${route}`, 404);\n  }\n  \n} catch (e) {\n  console.log(`[API] Error: ${e.message}`);\n  result = error(e.message, 500);\n}\n\nreturn [{ json: result }];"
                                     },
                      "type":  "n8n-nodes-base.code",
                      "typeVersion":  2,
                      "position":  [
                                       720,
                                       700
                                   ],
                      "id":  "api-handler",
                      "name":  "Route Handler"
                  },
                  {
                      "parameters":  {
                                         "respondWith":  "json",
                                         "responseBody":  "={{ $json }}",
                                         "options":  {
                                                         "responseHeaders":  {
                                                                                 "entries":  [
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Origin",
                                                                                                     "value":  "*"
                                                                                                 },
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Methods",
                                                                                                     "value":  "GET, POST, PUT, DELETE, OPTIONS"
                                                                                                 },
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Headers",
                                                                                                     "value":  "Content-Type, Authorization"
                                                                                                 },
                                                                                                 {
                                                                                                     "name":  "Content-Type",
                                                                                                     "value":  "application/json"
                                                                                                 }
                                                                                             ]
                                                                             }
                                                     }
                                     },
                      "type":  "n8n-nodes-base.respondToWebhook",
                      "typeVersion":  1.5,
                      "position":  [
                                       960,
                                       700
                                   ],
                      "id":  "api-respond",
                      "name":  "Send Response"
                  },
                  {
                      "parameters":  {
                                         "jsCode":  "return $input.all().map(item =\u003e ({ json: { ...item.json, method: \u0027GET\u0027 } }));"
                                     },
                      "type":  "n8n-nodes-base.code",
                      "typeVersion":  2,
                      "position":  [
                                       200,
                                       500
                                   ],
                      "id":  "add-get-method",
                      "name":  "Add GET"
                  },
                  {
                      "parameters":  {
                                         "jsCode":  "return $input.all().map(item =\u003e ({ json: { ...item.json, method: \u0027POST\u0027 } }));"
                                     },
                      "type":  "n8n-nodes-base.code",
                      "typeVersion":  2,
                      "position":  [
                                       200,
                                       700
                                   ],
                      "id":  "add-post-method",
                      "name":  "Add POST"
                  },
                  {
                      "parameters":  {
                                         "jsCode":  "return $input.all().map(item =\u003e ({ json: { ...item.json, method: \u0027PUT\u0027 } }));"
                                     },
                      "type":  "n8n-nodes-base.code",
                      "typeVersion":  2,
                      "position":  [
                                       200,
                                       900
                                   ],
                      "id":  "add-put-method",
                      "name":  "Add PUT"
                  },
                  {
                      "parameters":  {
                                         "jsCode":  "return $input.all().map(item =\u003e ({ json: { ...item.json, method: \u0027DELETE\u0027 } }));"
                                     },
                      "type":  "n8n-nodes-base.code",
                      "typeVersion":  2,
                      "position":  [
                                       200,
                                       1100
                                   ],
                      "id":  "add-delete-method",
                      "name":  "Add DELETE"
                  },
                  {
                      "parameters":  {
                                         "httpMethod":  "POST",
                                         "path":  "w-upload",
                                         "responseMode":  "responseNode",
                                         "options":  {
                                                         "binaryPropertyName":  "file",
                                                         "responseHeaders":  {
                                                                                 "entries":  [
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Origin",
                                                                                                     "value":  "*"
                                                                                                 }
                                                                                             ]
                                                                             }
                                                     }
                                     },
                      "type":  "n8n-nodes-base.webhook",
                      "typeVersion":  2.1,
                      "position":  [
                                       1200,
                                       500
                                   ],
                      "id":  "upload-webhook",
                      "name":  "Upload Webhook",
                      "webhookId":  "w-upload"
                  },
                  {
                      "parameters":  {
                                         "jsCode":  "const fs = require(\u0027fs\u0027);\nconst path = require(\u0027path\u0027);\nconst crypto = require(\u0027crypto\u0027);\nconst Database = require(\u0027better-sqlite3\u0027);\n\nconst { client_id, batch_id } = $input.first().json;\nconst binary = $input.first().binary?.file;\n\nif (!binary) {\n  return [{ json: { success: false, error: \u0027No file provided\u0027, code: 400 } }];\n}\nif (!client_id) {\n  return [{ json: { success: false, error: \u0027client_id required\u0027, code: 400 } }];\n}\n\n// Decode file first to check size\nconst buffer = Buffer.from(binary.data, \u0027base64\u0027);\nconst mimeType = binary.mimeType || \u0027application/octet-stream\u0027;\n\n// File validation\nconst MAX_FILE_SIZE = 500 * 1024 * 1024; // 500MB\nconst ALLOWED_TYPES = [\u0027image/jpeg\u0027, \u0027image/png\u0027, \u0027image/webp\u0027, \u0027image/gif\u0027, \u0027video/mp4\u0027, \u0027video/quicktime\u0027, \u0027video/webm\u0027];\n\nif (buffer.length \u003e MAX_FILE_SIZE) {\n  return [{ json: { success: false, error: \u0027File too large (max 500MB)\u0027, code: 400 } }];\n}\nif (!ALLOWED_TYPES.includes(mimeType)) {\n  return [{ json: { success: false, error: `Invalid file type: ${mimeType}. Allowed: jpg, png, webp, gif, mp4, mov, webm`, code: 400 } }];\n}\n\n// Path sanitization to prevent traversal attacks\nconst sanitizePath = (s) =\u003e String(s).replace(/[^a-zA-Z0-9_-]/g, \u0027\u0027);\nconst safeClientId = sanitizePath(client_id);\nconst safeBatchId = batch_id ? sanitizePath(batch_id) : \u0027pending\u0027;\n\n// Generate UUID and paths\nconst uuid = crypto.randomUUID();\nconst ext = path.extname(binary.fileName || \u0027.bin\u0027).toLowerCase();\nconst storagePath = `/data/uploads/${safeClientId}/${safeBatchId}`;\nconst fullPath = `${storagePath}/${uuid}${ext}`;\n\n// Create directory and write file\nfs.mkdirSync(storagePath, { recursive: true });\nfs.writeFileSync(fullPath, buffer);\n\n// Compute file hash\nconst hash = crypto.createHash(\u0027md5\u0027).update(buffer).digest(\u0027hex\u0027);\nconst isVideo = mimeType.startsWith(\u0027video/\u0027);\n\n// Insert into database\nconst db = new Database(\u0027/data/clients/_config/socialflow.db\u0027);\ntry {\n  const info = db.prepare(`\n    INSERT INTO files (client_id, batch_id, original_name, storage_path, uuid,\n                       file_size, mime_type, checksum, status, uploaded_at)\n    VALUES (?, ?, ?, ?, ?, ?, ?, ?, \u0027ready\u0027, datetime(\u0027now\u0027))\n  `).run(client_id, batch_id || null, binary.fileName, fullPath, uuid,\n         buffer.length, mimeType, hash);\n\n  return [{\n    json: {\n      success: true,\n      data: {\n        file: {\n          id: info.lastInsertRowid,\n          uuid,\n          storage_path: fullPath,\n          status: \u0027ready\u0027\n        }\n      }\n    }\n  }];\n} finally {\n  db.close();\n}"
                                     },
                      "type":  "n8n-nodes-base.code",
                      "typeVersion":  2,
                      "position":  [
                                       1400,
                                       500
                                   ],
                      "id":  "upload-handler",
                      "name":  "Upload Handler"
                  },
                  {
                      "parameters":  {
                                         "respondWith":  "json",
                                         "responseBody":  "={{ $json }}",
                                         "options":  {
                                                         "responseHeaders":  {
                                                                                 "entries":  [
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Origin",
                                                                                                     "value":  "*"
                                                                                                 }
                                                                                             ]
                                                                             }
                                                     }
                                     },
                      "type":  "n8n-nodes-base.respondToWebhook",
                      "typeVersion":  1.5,
                      "position":  [
                                       1600,
                                       500
                                   ],
                      "id":  "upload-respond",
                      "name":  "Upload Response"
                  },
                  {
                      "parameters":  {
                                         "httpMethod":  "POST",
                                         "path":  "w-onboarding-complete",
                                         "responseMode":  "responseNode",
                                         "options":  {
                                                         "responseHeaders":  {
                                                                                 "entries":  [
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Origin",
                                                                                                     "value":  "*"
                                                                                                 }
                                                                                             ]
                                                                             }
                                                     }
                                     },
                      "type":  "n8n-nodes-base.webhook",
                      "typeVersion":  2.1,
                      "position":  [
                                       1200,
                                       700
                                   ],
                      "id":  "onboarding-webhook",
                      "name":  "Onboarding Complete Webhook",
                      "webhookId":  "w-onboarding-complete"
                  },
                  {
                      "parameters":  {
                                         "jsCode":  "const Database = require(\u0027better-sqlite3\u0027);\nconst input = $input.first().json;\nconst { client_id, batch_id, start_date, schedule_strategy } = input;\n\nconst db = new Database(\u0027/data/clients/_config/socialflow.db\u0027);\n\ntry {\n  // Get client and batch info\n  const client = db.prepare(\u0027SELECT * FROM clients WHERE id = ?\u0027).get(client_id);\n  const batch = db.prepare(\u0027SELECT * FROM batches WHERE id = ?\u0027).get(batch_id);\n\n  if (!client || !batch) {\n    return [{ json: { success: false, error: \u0027Client or batch not found\u0027, code: 404 } }];\n  }\n\n  const files = db.prepare(`\n    SELECT * FROM files WHERE batch_id = ? AND status = \u0027ready\u0027 ORDER BY uploaded_at\n  `).all(batch_id);\n\n  if (!files.length) {\n    return [{ json: { success: false, error: \u0027No ready files found\u0027, code: 400 } }];\n  }\n\n  // Get existing content_ids to prevent duplicates\n  const existingIds = new Set(\n    db.prepare(\u0027SELECT content_id FROM content_items WHERE batch_id = ?\u0027)\n      .all(batch_id).map(r =\u003e r.content_id)\n  );\n\n  // Generate schedule dates\n  const startDate = new Date(start_date || new Date().toISOString().split(\u0027T\u0027)[0]);\n  const daysToAdd = schedule_strategy === \u0027weekly\u0027 ? 7 : 1;\n  let currentDate = new Date(startDate);\n  let created = 0;\n  let skipped = 0;\n  const timezone = client.timezone || \u0027Europe/Berlin\u0027;\n  const scheduledTime = \u002720:00:00\u0027;\n\n  const insertItem = db.prepare(`\n    INSERT INTO content_items (\n      content_id, client_id, batch_id, media_type, file_name, file_path,\n      file_size, file_hash, scheduled_date, scheduled_time, schedule_at, timezone,\n      slot, platforms, status, file_id, created_at\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \u0027feed\u0027, \u0027ig\u0027, \u0027NEEDS_AI\u0027, ?, datetime(\u0027now\u0027))\n  `);\n\n  const updateFile = db.prepare(\u0027UPDATE files SET content_item_id = ? WHERE id = ?\u0027);\n\n  const insertMany = db.transaction(() =\u003e {\n    for (let i = 0; i \u003c files.length; i++) {\n      const file = files[i];\n      const dateStr = currentDate.toISOString().split(\u0027T\u0027)[0];\n      const scheduleAt = `${dateStr}T${scheduledTime}`;\n      const mediaType = file.mime_type?.startsWith(\u0027video\u0027) ? \u0027video\u0027 : \u0027photo\u0027;\n      const contentId = `${client.slug}__${batch.slug}__${dateStr}__feed__${mediaType}__${String(i+1).padStart(2,\u00270\u0027)}`;\n\n      // Skip if content_id already exists\n      if (existingIds.has(contentId)) {\n        skipped++;\n        currentDate.setDate(currentDate.getDate() + daysToAdd);\n        continue;\n      }\n\n      const info = insertItem.run(\n        contentId, client_id, batch_id, mediaType, file.original_name,\n        file.storage_path, file.file_size, file.checksum, dateStr, scheduledTime,\n        scheduleAt, timezone, file.id\n      );\n      updateFile.run(info.lastInsertRowid, file.id);\n\n      currentDate.setDate(currentDate.getDate() + daysToAdd);\n      created++;\n    }\n  });\n\n  insertMany();\n\n  // Update batch status\n  db.prepare(`UPDATE batches SET status = \u0027ready\u0027 WHERE id = ?`).run(batch_id);\n\n  return [{\n    json: {\n      success: true,\n      data: {\n        client_slug: client.slug,\n        batch_slug: batch.slug,\n        file_count: files.length,\n        content_items_created: created,\n        skipped_duplicates: skipped\n      }\n    }\n  }];\n} finally {\n  db.close();\n}"
                                     },
                      "type":  "n8n-nodes-base.code",
                      "typeVersion":  2,
                      "position":  [
                                       1400,
                                       700
                                   ],
                      "id":  "onboarding-handler",
                      "name":  "Onboarding Complete Handler"
                  },
                  {
                      "parameters":  {
                                         "respondWith":  "json",
                                         "responseBody":  "={{ $json }}",
                                         "options":  {
                                                         "responseHeaders":  {
                                                                                 "entries":  [
                                                                                                 {
                                                                                                     "name":  "Access-Control-Allow-Origin",
                                                                                                     "value":  "*"
                                                                                                 }
                                                                                             ]
                                                                             }
                                                     }
                                     },
                      "type":  "n8n-nodes-base.respondToWebhook",
                      "typeVersion":  1.5,
                      "position":  [
                                       1600,
                                       700
                                   ],
                      "id":  "onboarding-respond",
                      "name":  "Onboarding Complete Response"
                  }
              ],
    "connections":  {
                        "GET Webhook":  {
                                            "main":  [
                                                         [
                                                             {
                                                                 "node":  "Add GET",
                                                                 "type":  "main",
                                                                 "index":  0
                                                             }
                                                         ]
                                                     ]
                                        },
                        "POST Webhook":  {
                                             "main":  [
                                                          [
                                                              {
                                                                  "node":  "Add POST",
                                                                  "type":  "main",
                                                                  "index":  0
                                                              }
                                                          ]
                                                      ]
                                         },
                        "PUT Webhook":  {
                                            "main":  [
                                                         [
                                                             {
                                                                 "node":  "Add PUT",
                                                                 "type":  "main",
                                                                 "index":  0
                                                             }
                                                         ]
                                                     ]
                                        },
                        "DELETE Webhook":  {
                                               "main":  [
                                                            [
                                                                {
                                                                    "node":  "Add DELETE",
                                                                    "type":  "main",
                                                                    "index":  0
                                                                }
                                                            ]
                                                        ]
                                           },
                        "Merge Requests":  {
                                               "main":  [
                                                            [
                                                                {
                                                                    "node":  "Route Parser",
                                                                    "type":  "main",
                                                                    "index":  0
                                                                }
                                                            ]
                                                        ]
                                           },
                        "Route Parser":  {
                                             "main":  [
                                                          [
                                                              {
                                                                  "node":  "Route Handler",
                                                                  "type":  "main",
                                                                  "index":  0
                                                              }
                                                          ]
                                                      ]
                                         },
                        "Route Handler":  {
                                              "main":  [
                                                           [
                                                               {
                                                                   "node":  "Send Response",
                                                                   "type":  "main",
                                                                   "index":  0
                                                               }
                                                           ]
                                                       ]
                                          },
                        "Add GET":  {
                                        "main":  [
                                                     [
                                                         {
                                                             "node":  "Merge Requests",
                                                             "type":  "main",
                                                             "index":  0
                                                         }
                                                     ]
                                                 ]
                                    },
                        "Add POST":  {
                                         "main":  [
                                                      [
                                                          {
                                                              "node":  "Merge Requests",
                                                              "type":  "main",
                                                              "index":  0
                                                          }
                                                      ]
                                                  ]
                                     },
                        "Add PUT":  {
                                        "main":  [
                                                     [
                                                         {
                                                             "node":  "Merge Requests",
                                                             "type":  "main",
                                                             "index":  0
                                                         }
                                                     ]
                                                 ]
                                    },
                        "Add DELETE":  {
                                           "main":  [
                                                        [
                                                            {
                                                                "node":  "Merge Requests",
                                                                "type":  "main",
                                                                "index":  0
                                                            }
                                                        ]
                                                    ]
                                       },
                        "Upload Webhook":  {
                                               "main":  [
                                                            [
                                                                {
                                                                    "node":  "Upload Handler",
                                                                    "type":  "main",
                                                                    "index":  0
                                                                }
                                                            ]
                                                        ]
                                           },
                        "Upload Handler":  {
                                               "main":  [
                                                            [
                                                                {
                                                                    "node":  "Upload Response",
                                                                    "type":  "main",
                                                                    "index":  0
                                                                }
                                                            ]
                                                        ]
                                           },
                        "Onboarding Complete Webhook":  {
                                                            "main":  [
                                                                         [
                                                                             {
                                                                                 "node":  "Onboarding Complete Handler",
                                                                                 "type":  "main",
                                                                                 "index":  0
                                                                             }
                                                                         ]
                                                                     ]
                                                        },
                        "Onboarding Complete Handler":  {
                                                            "main":  [
                                                                         [
                                                                             {
                                                                                 "node":  "Onboarding Complete Response",
                                                                                 "type":  "main",
                                                                                 "index":  0
                                                                             }
                                                                         ]
                                                                     ]
                                                        }
                    },
    "settings":  {
                     "executionOrder":  "v1"
                 },
    "pinData":  {

                },
    "active":  true,
    "meta":  {
                 "templateCredsSetupCompleted":  true
             },
    "tags":  [

             ],
    "versionId":  "cf12cc19-3340-408a-948d-e22decee9903"
}
